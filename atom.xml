<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>东北大苞米</title>
  
  <subtitle>Claye&#39;s Private Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xucha0.cn/"/>
  <updated>2019-06-10T11:09:22.000Z</updated>
  <id>http://www.xucha0.cn/</id>
  
  <author>
    <name>Claye</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue重构美团电商网站</title>
    <link href="http://www.xucha0.cn/Vue%E9%87%8D%E6%9E%84%E7%BE%8E%E5%9B%A2%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99/"/>
    <id>http://www.xucha0.cn/Vue重构美团电商网站/</id>
    <published>2019-06-10T11:09:22.000Z</published>
    <updated>2019-06-10T11:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>​项目地址： <a href="https://github.com/Clayeee/mt-app" target="_blank" rel="noopener">https://github.com/Clayeee/mt-app</a></p>          </div><a id="more"></a><h1 id="Vue重构美团电商网站"><a href="#Vue重构美团电商网站" class="headerlink" title="Vue重构美团电商网站"></a>Vue重构美团电商网站</h1><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>​        该网站是采用数据驱动模型的Vue框架搭建而成，在业务上分为首页、登陆/注册、产品列表、产品详情、购物车、订单等页面。在技术内容方面主要使用了<strong>Nuxt.js</strong>、<strong>Koa2</strong>。两者之间采用<strong>SSR( Vue Server Renderer)</strong>进行交互。数据状态的同步使用了<strong>Vuex</strong>。在前端技术方面，采用了最新的Vue2.5的语法，在脚手架上使用了<strong>Vue-Cli3</strong>。后端技术方面采用<strong>Koa2</strong>，数据缓存及数据库采用了<strong>Redis</strong>和<strong>MongoDB</strong>。同时，还采用了数据对象模型管理工具<strong>Mongoose</strong>。</p><p>​        业务技术细节方面，该平台开发了登陆/注册，SMTP服务，城市服务、推荐服务、搜索服务、地图服务、购物车、订单设计、组件的复用设计、接口设计、数据对象模型等模块，使之可以成为一个独立完成的网站系统。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="/images/mt/menu.png" alt="一体化"></p><h2 id="网站展示"><a href="#网站展示" class="headerlink" title="网站展示"></a>网站展示</h2><h3 id="平台首页"><a href="#平台首页" class="headerlink" title="平台首页"></a>平台首页</h3><p>​        首页部分由导航栏、搜索栏、菜单栏、商品陈列栏、底部信息五部分组成。其中，导航栏包含城市定位及切换城市功能、用户的登陆/注册以及静态的导航菜单栏。其具体样式如图所示。</p><p><img src="/images/mt/1.png" alt="img"></p><p>​        搜索栏包括平台logo（静态），搜索栏的功能与实现，以及平台保障信息的展示。其具体样式如图所示。</p><p><img src="/images/mt/2.png" alt="img"></p><p>​        菜单栏包含菜单栏的展示，菜单轮播图，用户登录注册接口。具体样式如图所示。</p><p><img src="/images/mt/3.png" alt="img"></p><p>​        商品陈列栏为热门商品信息的陈列与展示。具体样式如图5.6所示。</p><p><img src="/images/mt/4.png" alt="img"></p><p>​        底部栏为平台底部信息的展示，均为静态信息资源，具体样式如图所示。</p><p><img src="/images/mt/5.png" alt="img"></p><h3 id="用户登录、注册"><a href="#用户登录、注册" class="headerlink" title="用户登录、注册"></a>用户登录、注册</h3><ol><li><p>用户登录</p><p>​        当users表中存有用户数据时，点击平台登录接口，具体样式如图所示，即可登录用户，平台系统将自动把用户登录状态信息利用Redis服务器植入浏览器的cookie中。</p><p><img src="/images/mt/6.png" alt="img"></p></li><li><p>用户注册</p><p>​        当进入用户注册界面时需填写注册用户所必须的信息，浏览器在前台验证所填信息的完整性及正确性（如email格式是否正确，两次输入密码是否一致等）。具体的用户注册界面如图所示。</p><p><img src="/images/mt/7.png" alt="img"></p></li></ol><h3 id="城市选择页"><a href="#城市选择页" class="headerlink" title="城市选择页"></a>城市选择页</h3><p>​        当用户所期望的城市与用户所在城市不一致时，可手动切换所在城市。在切换城市页面中，用户可直接以省份&gt;城市的方式选择想切换的城市，也可以通过输入框搜索直接搜索城市（目前仅支持中文形式的搜素）。如果以上方式均达不到要求，也可使用英文首字母索引的方式，快速切换至城市所在的列表，具体样式如图所示。</p><p><img src="/images/mt/8.png" alt="img"></p><h3 id="商品列表页"><a href="#商品列表页" class="headerlink" title="商品列表页"></a>商品列表页</h3><p>​        当用户点击菜单或搜索商品时，浏览器向后台请求数据并将页面切换至相应的页面，具体样式如图所示。</p><p><img src="/images/mt/9.png" alt="img"></p><h3 id="商品详情页"><a href="#商品详情页" class="headerlink" title="商品详情页"></a>商品详情页</h3><p>​        当用户点击商品列表页的任意商品时，页面会切换至商品详情页，并展示可供用户购买的商品信息，具体样式如图所示。</p><p><img src="/images/mt/10.png" alt="img"></p><h3 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h3><p>​        当用户在系统点击购买商品时，系统会自动创建购物车并将所选商品添加至购物车中，具体页面样式如图所示。</p><p><img src="/images/mt/11.png" alt="img"></p><h3 id="订单详情页"><a href="#订单详情页" class="headerlink" title="订单详情页"></a>订单详情页</h3><p>​        当用户在购物车选择商品数量，并点击提交订单后，平台会自动生成订单并将页面切换至订单详情页，具体页面样式如图所示。</p><p><img src="/images/mt/12.png" alt="img"></p><h2 id="网站功能展示"><a href="#网站功能展示" class="headerlink" title="网站功能展示"></a>网站功能展示</h2><h3 id="注册、登陆功能测试"><a href="#注册、登陆功能测试" class="headerlink" title="注册、登陆功能测试"></a>注册、登陆功能测试</h3><p>​        切换至用户注册界面输入信息，将邮箱格式输入错误，发现系统页面输出提示信息，如图所示，邮箱格式验证功能良好。</p><p><img src="/images/mt/20.png" alt="img"></p><p>​        继续向下输入，将两次密码设置为不相同，系统提示错误，密码一致性功能良好，如图所示。</p><p><img src="/images/mt/21.png" alt="img"></p><p>​        将所有信息填写正确，点击发送验证码。邮箱接收到用户注册验证码邮件，用户注册验证功能良好，具体内容如图所示。</p><p><img src="/images/mt/22.jpg" alt="注册流程"></p><p>​        切换至用户登录界面，将刚才所注册的用户进行登录测试，登陆成功，登录接口功能良好，具体流程如图所示。</p><p><img src="/images/mt/23.jpg" alt="绘图1"></p><h3 id="城市定位切换测试"><a href="#城市定位切换测试" class="headerlink" title="城市定位切换测试"></a>城市定位切换测试</h3><p>​        进入城市定位切换界面，选择省份&gt;城市（在省份未选择前城市项不可用），切换城市成功，通过测试，如图所示。</p><p><img src="/images/mt/24.png" alt="img"></p><p>​        在搜索框内输入哈尔滨，列表框提示信息，点击切换，城市切换成功。具体流程如图所示。</p><p><img src="/images/mt/25.png" alt="img"></p><p>​        在字母导航栏中点击城市，城市切换成功。具体流程如图所示。</p><p><img src="/images/mt/26.png" alt="img"></p><h3 id="搜索框测试"><a href="#搜索框测试" class="headerlink" title="搜索框测试"></a>搜索框测试</h3><p>​        在首页搜索框中添加搜索信息，搜索框弹出提示。点击搜索按钮，页面切换至商品列表页，搜索功能良好。具体流程如图所示。</p><p><img src="/images/mt/27.jpg" alt="搜索"></p><h3 id="商品购买流程测试"><a href="#商品购买流程测试" class="headerlink" title="商品购买流程测试"></a>商品购买流程测试</h3><p>​        点击商品列表，进入列表详情页，点击商品购买进入购物车页面，选择两个商品数量点击下单，创建订单页面，具体流程图如图所示。</p><p><img src="/images/mt/28.jpg" alt="购买流程"></p><p>​        数据库购物车数据及订单数据如图所示。</p><p><img src="/images/mt/29.jpg" alt="数据库"></p><h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install dependencies</span></span><br><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># serve with hot reload at localhost:3000</span></span><br><span class="line">$ npm run dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># build for production and launch server</span></span><br><span class="line">$ npm run build</span><br><span class="line">$ npm start</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate static project</span></span><br><span class="line">$ npm run generate</span><br></pre></td></tr></table></figure><p><strong>注</strong>：项目运行前请先运行Redis和MongoDB服务，Mongo数据表数据在项目目录data文件夹下，利用<code>mongod --dbpath &#39;./data&#39;</code>命令执行</p><h5 id="联系我：1269575798-qq-com"><a href="#联系我：1269575798-qq-com" class="headerlink" title="联系我：1269575798@qq.com"></a>联系我：<a href="mailto:1269575798@qq.com" target="_blank" rel="noopener">1269575798@qq.com</a></h5><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;​项目地址： &lt;a href=&quot;https://github.com/Clayeee/mt-app&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Clayeee/mt-app&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://www.xucha0.cn/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://www.xucha0.cn/tags/Vue/"/>
    
      <category term="Nuxt.js" scheme="http://www.xucha0.cn/tags/Nuxt-js/"/>
    
      <category term="Koa" scheme="http://www.xucha0.cn/tags/Koa/"/>
    
      <category term="MongoDB" scheme="http://www.xucha0.cn/tags/MongoDB/"/>
    
      <category term="项目" scheme="http://www.xucha0.cn/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>ES6笔记</title>
    <link href="http://www.xucha0.cn/ES6%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.xucha0.cn/ES6笔记/</id>
    <published>2019-03-19T02:38:33.000Z</published>
    <updated>2019-03-19T02:38:33.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>ES6新特性内容笔记（未完成）</p>          </div><h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h2><ol><li><p>不存在变量提升（变量声明前不可用）</p></li><li><p>暂时性死区（变量声明前，不可复制，注意 <em><code>typeof</code>不再是绝对安全的</em>）</p><blockquote><p>当一个变量出现暂时性死区，在使用typeof方法时则会报错，如果是普通的<code>var</code>变量，则返回<code>undefined</code></p></blockquote></li></ol><a id="more"></a><ol start="3"><li><p>不允许重复声明</p><blockquote><p>相同作用域内不允许重复声明变量，函数内不允许重新定义参数</p></blockquote></li><li><p>块级作用域</p><blockquote><p>解决内层变量覆盖外层变量，局部变量泄露为全局变量的问题</p><p>解决使用立即执行代码的问题 <strong>( function ( ) { … } ( ) );</strong></p></blockquote></li><li><p><code>const</code>指向一个内存地址，当内存地址内的对象发生改变，<code>const</code>不报错</p></li></ol><h4 id="ES声明变量的6种方法"><a href="#ES声明变量的6种方法" class="headerlink" title="ES声明变量的6种方法"></a>ES声明变量的6种方法</h4><ul><li>ES5：<code>var、function</code></li><li>ES6：<code>let、const、class、import</code></li></ul><ol start="6"><li><p>全局变量不再与顶级对象属性挂钩 <code>( window.a != let/const a )</code></p></li><li><p>顶级对象<code>global</code></p><blockquote><p>由于在不同环境下的顶级对象差异（浏览器下为<code>window</code>，<code>nodejs</code>中为<code>global</code>），在各种环境中设置顶级对象global使其在所有环境下能够被访问</p></blockquote></li></ol><h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><p>从数组和对象中提取值，对变量进行赋值</p><ul><li>左右两侧结构相同</li><li>等式右边必须是合法数据类型</li><li>必须在声明时赋值</li></ul><h4 id="数组的结构赋值"><a href="#数组的结构赋值" class="headerlink" title="数组的结构赋值"></a>数组的结构赋值</h4><ol><li><p>等式两边的值必须都是可迭代对象</p></li><li><p>利用“模式匹配”的方式将可迭代对象拆分赋值</p></li><li><p>当等式左边只匹配右边一部分的模式，称为“不完全匹配”，也可赋值成功</p></li><li><p>默认值</p><blockquote><p>结构赋值允许指定默认值，但只有结构变量严格等于 ( === ) <code>undefined</code>，默认值才会生效</p></blockquote></li></ol><h4 id="对象的结构赋值"><a href="#对象的结构赋值" class="headerlink" title="对象的结构赋值"></a>对象的结构赋值</h4><ol><li><p>对象属性无次序，所以要赋值变量名必须与对象属性名相同，一一对应</p><blockquote><p>如果变量名与属性名不一致则必须写成 <code>let { val : foo } = { foo : &#39;hello world&#39; }   // foo = &#39;hello world&#39;</code></p></blockquote></li></ol><h4 id="字符串的结构赋值"><a href="#字符串的结构赋值" class="headerlink" title="字符串的结构赋值"></a>字符串的结构赋值</h4><blockquote><p>字符串会被转换为一个类数组对象进行结构赋值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a,b,c,d,e] = <span class="string">'hello'</span>    <span class="comment">// a='h',b='e',c='l',d='l',e='o'</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">lenth</span>: len&#125; = <span class="string">'hello'</span>   <span class="comment">// lenth=5</span></span><br></pre></td></tr></table></figure><h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><h4 id="Unicode字符串方法"><a href="#Unicode字符串方法" class="headerlink" title="Unicode字符串方法"></a>Unicode字符串方法</h4><ol><li><p>字符的<code>Unicode</code>表示法（采用大括号的形式解决字符编码上限问题）</p></li><li><p><code>codePointAt()</code>方法正确返回占用4个字节的字符码点（十进制）</p></li><li><p><code>String.fromCharCode()</code>方法正确将码点返回成对应字符</p></li><li><p>字符串的遍历接口 <code>for ... of</code> （能够正确遍历占用4个字节的字符）</p></li><li><p><code>normalize()</code>方法（Unicode 正规化）</p><blockquote><p>许多语言有语调符号和重音符号</p><p>在ES5中 直接提供带重音符号的字符 != 合成符号，即原字符与重音符号的合成，两个字符合成一个字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()  <span class="comment">//ture</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><ol><li><p>查询方法</p><ul><li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li><li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul></li><li><code>repeat( n )</code>方法：返回一个新的字符串，将原字符串循环n次</li><li><code>padStart(lenth, str)，padEnd(lenth，str)</code>字符串补全长度方法</li><li><code>matchAll()</code>方法返回一个正则表达式在当前字符串的所有匹配</li></ol><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><ol><li><p>模板字符串： `…` ，可换行，并且会保留所有的空格和缩进</p></li><li><p>模板字符串绑定变量的方式 ：<code>${ value|function }</code></p></li><li><p>模板编译：使用<code>&lt;%...%&gt;</code>放置 JavaScript 代码，使用<code>&lt;%= ... %&gt;</code>输出 JavaScript 表达式</p></li><li><p>标签模板</p><blockquote><p>将模板紧跟在一个函数的后面，该函数则用来处理这个模板，例如：alert`hello world`</p><p>实质是调用函数的另一种表达形式</p></blockquote></li><li><p><code>String.raw()</code>方法：处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用</p></li></ol><h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><ol><li>二进制和八进制的表示法：二进制-&gt; <code>0B|0b</code>，八进制-&gt; <code>0o|0O</code></li><li>十进制转换：<code>Number( 0b|0o )</code></li><li><p><code>Number.isFinite()</code>和<code>Number.isNaN()</code>方法</p><ul><li><code>Number.isFinite()</code> 用于查询一个数字是否是有限的，即不是<code>Infinity</code></li><li><code>Number.isNaN()</code>用于检查一个值是否为NaN</li></ul></li><li><code>Number.parseInt(), Number.parseFloat()</code>从<code>window</code>对象移植，功能不变</li><li><code>Number.isInteger()</code>：判断一个数值是否为整数，非数字类型返回<code>false</code>（<strong>超过IEEE754精度以及极限值都会存在误差</strong>）</li><li><code>Number.EPSILON</code>，常量，等于0.0(52个)1，实际表示JS的最小精度，可以用来设置误差范围</li><li>安全整数和 <code>Number.isSafeInteger()</code><ul><li><code>Number.MAX_SAFE_INTEGER = 2^53</code>和<code>Number.MIN_SAFE_INTEGER = -2^53</code>：常量，表示JS整数上下限</li><li><code>Number.isSafeInteger()</code>方法，用于判断数值是否在安全整数范围内</li></ul></li></ol><h4 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h4><ol><li><code>Math.trunc()</code>方法：去除一个数的小数部分，返回整数部分</li><li><code>Math.sign()</code>方法：判断一个数是正数（返回+1），负数（返回-1），还是零（返回0或-0）</li><li><code>Math.cbrt()</code>方法：用于计算一个数的立方根</li><li><code>Math.clz32()</code>方法：将参数转化为32位无符号整数形式</li><li><code>Math.imul()</code>方法：返回两个数以32位带符号整数形式相乘的结果</li><li><code>Math.fround()</code>方法：返回一个数的32位单精度浮点数形式</li><li><code>Math.hypot()</code>方法：返回所有参数的平方和的平方根</li></ol><h5 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h5><ol><li><code>Math.expm1(x)</code>方法：返回e^x - 1，即<code>Math.exp(x)-1</code></li><li><code>Math.log1p(x)</code>方法：返回1+x的自然对数，即<code>Math.log(1 + x)</code></li><li><code>Math.log10(x)</code>方法：返回以10为底的x的对数</li><li><code>Math.log2(x)</code>方法：返回以2为底x的对数</li></ol><h5 id="双曲函数方法"><a href="#双曲函数方法" class="headerlink" title="双曲函数方法"></a>双曲函数方法</h5><ul><li><code>Math.sinh(x)</code> 返回<code>x</code>的双曲正弦（hyperbolic sine）</li><li><code>Math.cosh(x)</code> 返回<code>x</code>的双曲余弦（hyperbolic cosine）</li><li><code>Math.tanh(x)</code> 返回<code>x</code>的双曲正切（hyperbolic tangent）</li><li><code>Math.asinh(x)</code> 返回<code>x</code>的反双曲正弦（inverse hyperbolic sine）</li><li><code>Math.acosh(x)</code> 返回<code>x</code>的反双曲余弦（inverse hyperbolic cosine）</li><li><code>Math.atanh(x)</code> 返回<code>x</code>的反双曲正切（inverse hyperbolic tangent）</li></ul><h4 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h4><p><strong>**</strong> ：右结合运算符，多个指数运算符优先算右面的</p><h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><ol><li><p>函数参数的默认值（不能出现同名参数，惰性求值，尽量定义在尾部）</p><ul><li><p><code>length</code>属性：返回没有指定默认值的参数个数（如果默认值参数不是尾参数，则只返回默认参数前面未指定默认值的参数个数）</p></li><li><p>作用域：设置了默认值的参数，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束时，这个作用域会消失。</p></li></ul></li><li><p><code>rest</code>参数：形式为<code>...变量名</code>，该变量名对应一个类数组对象，用于获取函数的多余参数，类似于<code>arguments</code></p></li><li><p>严格模式：只要函数参数使用了默认值，解构赋值，扩展运算符，那么函数内部就不能显式设定为严格模式</p></li><li><p><code>name</code>属性：返回函数的函数名，匿名函数会返回被赋值的变量名（<code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>）</p></li><li><p>箭头函数：使用箭头定义函数（<code>“ () =&gt; { ... }”</code>）</p><ul><li>函数体内的<code>this</code>对象，是定义时所在的对象，而不是使用时所在的对象</li><li>不可以当做构造函数，即不可食用<code>new</code>命令</li><li>函数体内没有<code>arguments</code>对象，不可用，可以用<code>...rest</code>代替</li><li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</li></ul><blockquote><p>当只有一个参数时，参数的圆括号可以省去</p><p>当只有一个<code>return</code>时，花括号和<code>return</code>可以同事省去</p></blockquote></li><li><p>双冒号运算符：函数绑定运算符，双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为<code>this</code>对象绑定到右边的函数上面</p></li><li><p>尾调用优化：在函数尾部返回调用其他函数，则只保留内层函数调用帧，外层函数由于已经返回不会再用到则不会保留调用帧，所以其内部调用帧会取代外部调用帧</p><blockquote><p>ES6的尾调用优化比现在严格模式下开启，正常模式无效。</p><p>正常模式下，函数内部有两个变量<code>arguments</code>和<code>caller</code>，可以跟踪函数的调用栈</p></blockquote></li><li><p>尾递归：一个函数返回函数本身进行递归，则只保留一个调用帧，不会出现栈溢出现象</p><ul><li>改写：将所有的内部变量改写成函数参数</li></ul><blockquote><p>在严格模式下实现，非严格模式下减少调用栈的方法就是采用循环替代递归</p></blockquote></li><li><p>函数参数的尾逗号：允许函数在最后一个参数后面添加一个逗号</p></li></ol><h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><ol><li><p>扩展运算符（<code>...</code>），类似于<code>...rest</code>参数逆运算，将一个数组转化为用逗号分隔的参数序列</p><ul><li>可以替代函数的<code>apply</code>方法</li><li>复制数组（直接复制数组，只是复制了数组的指针）</li><li>合并数组</li><li>与解构赋值结合</li><li>将字符串转化为数组</li><li>可迭代对象</li></ul></li><li><p><code>Array.from()</code>方法：将类数组对象和可迭代对象转化为数组</p><blockquote><p>该方法可以接受第二个参数，其作用类似于map方法，返回一个数组</p></blockquote></li><li><p><code>Array.of()</code>方法：将一组值转化为数组</p></li><li><p><code>copyWithin(target, start = 0, end = this.length)</code>方法：在数组内部将指定位置的成员复制到其他位置（会覆盖原有成员）。</p><ul><li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li><li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li></ul></li><li><p><code>find()</code>和<code>findIndex()</code>方法</p><ul><li><code>Array.find( func )</code>：根据函数所提供的规则找出符合规则的第一个元素，如果整个数组都没有则返回<code>undefined</code></li><li><code>Array.findIndex( func )</code>：返回的是下标，没有则返回-1</li></ul><blockquote><p>这两个方法的第二个参数，用于绑定this指向的对象</p></blockquote></li><li><p>数组实例的<code>fill()</code>方法：给定一个参数值用于填充整个数组（第二、三个参数用于指定起始和结束位置，可选）</p></li><li><p>数组实例的 <code>entries()</code>，<code>keys()</code> 和 <code>values()</code>：遍历数组。</p><ul><li><code>entries()</code>：返回数组键值对</li><li><code>keys()</code>：返回键</li><li><code>values()</code>：返回值</li></ul></li><li><p><code>includes()</code>方法：查询数组中是否包含给定的值，返回布尔值（可以给定第二个参数为查询的起始位置）</p></li><li><p><code>flat()</code>，<code>flatMap()</code>方法</p><ul><li><code>flat()</code>：将多维数组拉平，默认只拉平一层，可以给定参数选择拉平的层数</li><li><code>flatMap()</code>：先对数组内的元素执行<code>map()</code>，然后执行<code>flat()</code>方法</li></ul></li></ol><h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><ol><li>属性和方法可以简写</li><li>属性名表达式：可以同时使用标识符和表达式作为对象的属性名</li><li>方法的<code>name</code>属性：返回方法名</li><li>属性的遍历：<ul><li><code>for ... in</code></li><li><code>Object.keys(obj)</code>：返回可枚举属性的键名数组</li><li><code>Object.getOwnPropertyNames(obj)</code>：返回所有属性的键名数组（不包括Symbol）</li><li><code>Object.getOwnPropertySymbols(obj)</code>：返回所有Symbol属性的键名</li><li><code>Reflect.ownKeys(obj)</code>：返回对象的所有属性</li></ul></li><li><code>super</code>关键字：指向当前对象的原型对象（只能在对象的方法中使用）</li><li>对象的扩展运算符：( <code>...</code> )将所有可遍历属性，解构赋值在其他对象中<ul><li>对象的扩展运算符也可以用到数组，将数组转换为对象，键为数组元素的下标</li><li>如果用到字符串，会将字符串转化为类数组对象</li></ul></li></ol><h2 id="对象的新增方法"><a href="#对象的新增方法" class="headerlink" title="对象的新增方法"></a>对象的新增方法</h2><ol><li><p><code>Object.is()</code>方法用来比较两个值是否相等。（解决了 <code>==</code> 和 <code>===</code> 的缺陷）</p></li><li><p><code>Object.assgin()</code>方法用于对象合并，第一个参数为目标对象，后续参数为源对象</p><blockquote><p>如果合并的对象有相同的属性，那么后面的会覆盖前面的属性</p></blockquote></li><li><p><code>Object.getOwnPropertyDescriptors()</code>方法：返回指定对象所有自身属性的描述对象</p></li><li><p><code>__proto__</code>属性，<code>Object.setPrototypeOf()</code>，<code>Object.getPrototypeOf()</code></p><ul><li><code>__proto__</code>：用来设置当前对象的<code>prototype</code>对象<!--不建议直接使用--></li><li><code>Object.setPrototypeOf()</code>：用来设置一个对象的<code>prototype</code>对象，返回对象本身</li><li><code>Object.getPrototypeOf()</code>：用于读取一个对象的prototype对象</li></ul></li><li><p><code>Object.keys()</code>，<code>Object.values()</code>，<code>Object.entries()</code></p><ul><li><code>Object.keys()</code>： 返回一个含有所有可枚举属性键名的数组</li><li><code>Object.values()</code>：返回一个含有所有可枚举属性键值的数组</li><li><code>Object.entries()</code>：返回一个含有所有属性键值对的二维数组</li></ul></li><li><p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>方法的逆方法，用于将一个二维数组转化为对象</p></li></ol><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><ul><li>原始数据类型，表示独一无二的值，ES中第七种原始数据类型</li></ul><ul><li><p>利用symbol函数构成，可对对象新增已有的属性名而不发生冲突（原有字符串属性名，现有symbol属性名）</p></li><li><p>利用方括号 <code>[]</code> 访问<code>Symbol</code>对象属性，不可以用点操作符</p></li><li><p>Symbol类型不会被普通的<code>for ... in</code>，<code>for ... of</code> 循环到，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>方法返回</p><blockquote><p>使用<code>Object.getOwnPropertySymbols()</code>方法，可以获得对象内所有<code>Symbol</code>属性名</p></blockquote></li><li><p><code>Reflect.ownKeys(obj)</code>返回所有类型的键名，包括<code>Symbol</code>类型</p></li><li><p><code>Symbol.for(str)</code> 查找是否有以此字符串为标识的<code>Symbol</code>值，有，则返回，无，则新建</p></li><li><p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>，如果没有则不新建</p></li></ul><h2 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h2><h3 id="Set-类数组集合"><a href="#Set-类数组集合" class="headerlink" title="Set 类数组集合"></a>Set 类数组集合</h3><ul><li>构造函数，利用实例化对象构造( <code>new Set()</code> )<ul><li>利用<code>add()</code>方法添加新值</li><li>可以再实例化对象时传入一个数组或可迭代对象</li></ul></li></ul><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><code>add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>clear()</code>：清除所有成员，没有返回值。</li></ul><blockquote><p><code>Array.from</code>方法可以将 Set 结构转为数组。</p></blockquote><!--提供另一种数组去重的方法--><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><ul><li><code>keys()</code>：返回键名的遍历器</li><li><code>values()</code>：返回键值的遍历器</li><li><code>entries()</code>：返回键值对的遍历器</li><li><code>forEach()</code>：使用回调函数遍历每个成员</li></ul><h3 id="Weak-Set"><a href="#Weak-Set" class="headerlink" title="Weak Set"></a>Weak Set</h3><p><code>WeakSet</code> 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><ol><li><strong><code>WeakSet</code> 的成员只能是对象</strong>，而不能是其他类型的值。</li><li><strong><code>WeakSet</code> 中的对象都是弱引用</strong></li></ol><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul><li><strong>WeakSet.prototype.add(value)</strong>：向 WeakSet 实例添加一个新成员。</li><li><strong>WeakSet.prototype.delete(value)</strong>：清除 WeakSet 实例的指定成员。</li><li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在 。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>提供一种键值对的数据结构，并且键名不再强制要求为字符串类型，即可以为  <strong>值-&gt;值</strong> 形式</p><h4 id="属性和操作方法"><a href="#属性和操作方法" class="headerlink" title="属性和操作方法"></a>属性和操作方法</h4><ol><li><strong><code>size</code>属性</strong>：返回 Map 结构的成员总数</li><li><strong><code>set(key, value)</code></strong>：更新键值对，返回Map对象</li><li><strong>get(key)</strong>：读取<code>key</code>对应的键值</li><li><strong>has(key)</strong>：查询<code>Map</code>对象是否存在指定的键值</li><li><strong>delete(key)</strong>：删除一个键值，返回删除结果</li><li><strong>clear()</strong>：清除所有成员</li></ol><h4 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h4><ul><li><code>keys()</code>：返回键名的遍历器。</li><li><code>values()</code>：返回键值的遍历器。</li><li><code>entries()</code>：返回所有成员的遍历器。</li><li><code>forEach()</code>：遍历 Map 的所有成员。</li></ul><h4 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h4><ul><li><strong>Map 转为数组</strong>：利用扩展运算符<code>[ ... ]</code></li><li><strong>数组 转为 Map</strong>：利用<code>Map</code>构造函数实例化对象</li><li><strong>Map 转为对象</strong>：直接转换，但键名必须为字符串</li><li><strong>对象转为 Map</strong>：直接转换</li></ul><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>与<code>WeakSet</code>类似</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><ul><li>用于修改某些操作的默认行为，在<strong>语言层面</strong>作出修改</li><li>相当于在某些对象外假设一层“拦截”，可以对访问对象操作进行过滤和改写</li></ul><p>利用<code>proxy</code>构造函数可以实例化一个对象，对其进行代理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><blockquote><p> <code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;ES6新特性内容笔记（未完成）&lt;/p&gt;
          &lt;/div&gt;
&lt;h2 id=&quot;let和const&quot;&gt;&lt;a href=&quot;#let和const&quot; class=&quot;headerlink&quot; title=&quot;let和const&quot;&gt;&lt;/a&gt;let和const&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不存在变量提升（变量声明前不可用）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;暂时性死区（变量声明前，不可复制，注意 &lt;em&gt;&lt;code&gt;typeof&lt;/code&gt;不再是绝对安全的&lt;/em&gt;）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当一个变量出现暂时性死区，在使用typeof方法时则会报错，如果是普通的&lt;code&gt;var&lt;/code&gt;变量，则返回&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="node.js" scheme="http://www.xucha0.cn/categories/node-js/"/>
    
    
      <category term="Web前端" scheme="http://www.xucha0.cn/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://www.xucha0.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="node" scheme="http://www.xucha0.cn/tags/node/"/>
    
      <category term="ES6" scheme="http://www.xucha0.cn/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Windows安全日志解析工具</title>
    <link href="http://www.xucha0.cn/Windows%E5%AE%89%E5%85%A8%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.xucha0.cn/Windows安全日志解析工具/</id>
    <published>2019-02-26T11:24:47.000Z</published>
    <updated>2019-02-26T11:24:47.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>项目地址：<a href="https://github.com/Clayeee/Win-Logs-Parse-tool" target="_blank" rel="noopener">https://github.com/Clayeee/Win-Logs-Parse-tool</a></p>          </div><a id="more"></a><p>Tool Name : Windows Safe Logs Parse Tool<br>Version   : v 1.0.0<br>Developer : Xu Chao<br>E-mail    : <a href="mailto:1269575798@qq.com" target="_blank" rel="noopener">1269575798@qq.com</a><br>Date      : 19/02/26</p><h1 id="Windows安全日志解析工具"><a href="#Windows安全日志解析工具" class="headerlink" title="Windows安全日志解析工具"></a>Windows安全日志解析工具</h1><p>可解析windows系统目录下的安全日志文件 ( 需获取管理员权限 )，也可采用手动添加文件的方式进行解析，解析后的文件为XML，HTML两种格式，HTML已采用Bootstrap框架进行界面可视化优化，可直接查看重点日志数据，解析后的HTML数据文件保存在执行文件下的<code>logs/</code>文件夹下 ( 自动创建 )，XML数据文件保存在执行文件下的<code>logs/xml/</code>文件夹下，本工具采用Python语言开发。</p><h3 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点</h3><ul><li>日志文件可视化解析</li><li>原始数据保存为XML文件</li><li>管理员运行可直接解析系统日志</li><li>可采用手动添加文件或目录方式进行解析</li></ul><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -s, --system          读取并解析指定的windows日志</span><br><span class="line">  -f FILE, --file FILE  指定一个evtx文件进行解析</span><br><span class="line">  -d DIR, --dir DIR     指定一个目录，解析目录下所有evtx文件(默认为系统日志文件夹)</span><br></pre></td></tr></table></figure><h3 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├─import              # 引用模块</span><br><span class="line">├─argparse            # 参数解析模块</span><br><span class="line">├─parse_logs          # evtx日志文件解析模块</span><br><span class="line">├─XML_parse           # XML数据解析模块</span><br><span class="line">├─save_data           # 数据保存模块</span><br><span class="line">└─__main__            # 主模块</span><br></pre></td></tr></table></figure><h3 id="功能详情"><a href="#功能详情" class="headerlink" title="功能详情"></a>功能详情</h3><ul><li><h5 id="argparse——参数解析模块"><a href="#argparse——参数解析模块" class="headerlink" title="argparse——参数解析模块"></a><code>argparse</code>——参数解析模块</h5><ul><li><p>所需模块：<code>argparse</code></p></li><li><p>功能： <code>-h  --help</code> :  显示参数帮助文档</p><p>​             <code>-s --system</code> : 读取并解析系统日志，需手动选择解析文件</p><p>​         <code>-f  --file</code> : 指定日志文件进行解析，如执行：<code>python tool.py -f D:/Application.evtx</code></p><p>​         <code>-d --dir</code> : 指定目录，解析目录下所有日志文件，如执行：<code>python tool.py -f D:/log/</code></p></li></ul></li><li><h5 id="parse-logs——evtx日志文件解析模块"><a href="#parse-logs——evtx日志文件解析模块" class="headerlink" title="parse_logs——evtx日志文件解析模块"></a><code>parse_logs</code>——<code>evtx</code>日志文件解析模块</h5><ul><li>所需模块：<code>Evtx,contextlib,mmap</code></li><li>功能：利用<code>python-evtx</code>模块解析<code>.evtx</code>文件数据，遍历事件，将事件解析为<code>XML</code>数据格式，单个事件顶级标签为<event>，返回单个文件解析的所有<code>XML</code>数据。</event></li></ul></li><li><h5 id="XML-parse——XML数据解析模块"><a href="#XML-parse——XML数据解析模块" class="headerlink" title="XML_parse——XML数据解析模块"></a><code>XML_parse</code>——<code>XML</code>数据解析模块</h5><ul><li>所需模块：<code>xml.dom.minidom</code></li><li>功能：将 XML 数据在内存中解析成一个树，通过对树的操作来操作 XML。返回一个字典列表，列表长度为文件内事件数，字典内保存获取的数据。</li></ul></li><li><h5 id="save-data——-数据保存模块"><a href="#save-data——-数据保存模块" class="headerlink" title="save_data—— 数据保存模块"></a><code>save_data</code>—— 数据保存模块</h5><ul><li>所需模块：<code>os,codecs,string.Template</code></li><li>功能：通过传入的<code>mod</code>参数判断保存数据格式<ul><li>XML下：<ol><li>判断是否存在<code>log/xml/</code>文件夹，不存在则创建</li><li>写入与<code>evtx</code>文件同名的<code>XML</code>文件</li><li>为XML文件添加顶级标签<data> <!--不添加则无法解析XML文件--></data></li><li>写入<code>parse_logs</code>返回的<code>XML</code>数据</li></ol></li><li>HTML下：<ol><li>利用字符串模板，将提前定义好的<code>html</code>文件模板字符串的变量进行替换</li><li>循环遍历<code>XML_parse</code>返回的列表，将变量绑定至<code>HTML</code>文件</li><li>单个列表绑定一个<code>table</code>表格</li><li>写入数据</li></ol></li></ul></li></ul></li><li><h5 id="main-——程序入口"><a href="#main-——程序入口" class="headerlink" title="__main__——程序入口"></a><code>__main__</code>——程序入口</h5><ol><li>判断参数</li><li>遍历目录（如解析单个文件则没有此功能）</li><li>将.evtx文件解析为XML数据</li><li>将XML数据保存为XML文件</li><li>将XML文件数据解析为DOM树，获取数据并返回一个字典列表</li><li>将字典列表数据通过字符串模板写入HTML文件内</li></ol></li></ul><h3 id="程序演示"><a href="#程序演示" class="headerlink" title="程序演示"></a>程序演示</h3><h5 id="执行-help参数："><a href="#执行-help参数：" class="headerlink" title="执行--help参数："></a>执行<code>--help</code>参数：</h5><p><img src="/images/win_log_parse/--help.png" alt="--help"></p><h5 id="执行-system参数："><a href="#执行-system参数：" class="headerlink" title="执行--system参数："></a>执行<code>--system</code>参数：</h5><h6 id="​文件选择界面："><a href="#​文件选择界面：" class="headerlink" title="​文件选择界面："></a>​文件选择界面：</h6><p><img src="/images/win_log_parse/-s1.png" alt="-s 1"></p><p><img src="/images/win_log_parse/-s2.png" alt="-s 2"></p><h5 id="执行-file参数："><a href="#执行-file参数：" class="headerlink" title="执行--file参数："></a>执行<code>--file</code>参数：</h5><p><img src="/images/win_log_parse/-f.png" alt="-f"></p><h5 id="自动创建文件夹及文件："><a href="#自动创建文件夹及文件：" class="headerlink" title="自动创建文件夹及文件："></a>自动创建文件夹及文件：</h5><p><img src="/images/win_log_parse/dir2.png" alt="dir2"></p><h5 id="XML文档内容："><a href="#XML文档内容：" class="headerlink" title="XML文档内容："></a><code>XML</code>文档内容：</h5><p><img src="/images/win_log_parse/xml.png" alt="xml"></p><h5 id="HTML文档内容："><a href="#HTML文档内容：" class="headerlink" title="HTML文档内容："></a><code>HTML</code>文档内容：</h5><p><img src="/images/win_log_parse/html.png" alt="html"></p><h5 id="执行-dir参数："><a href="#执行-dir参数：" class="headerlink" title="执行--dir参数："></a>执行<code>--dir</code>参数：</h5><p><img src="/images/win_log_parse/-d.png" alt="-d"></p><h3 id="已知缺陷"><a href="#已知缺陷" class="headerlink" title="已知缺陷"></a>已知缺陷</h3><ul><li>采用阻塞式I/O开发，在解析大文件或目录下多个文件时程序运行较慢。</li></ul><h3 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3><hr><h2 id="Email：1269575798-qq-com"><a href="#Email：1269575798-qq-com" class="headerlink" title="Email：1269575798@qq.com"></a>Email：<a href="mailto:1269575798@qq.com" target="_blank" rel="noopener">1269575798@qq.com</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/Clayeee/Win-Logs-Parse-tool&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Clayeee/Win-Logs-Parse-tool&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://www.xucha0.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.xucha0.cn/tags/Python/"/>
    
      <category term="日志分析" scheme="http://www.xucha0.cn/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    
      <category term="Windows" scheme="http://www.xucha0.cn/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>服务器开放端口扫描工具</title>
    <link href="http://www.xucha0.cn/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.xucha0.cn/服务器开放端口扫描工具/</id>
    <published>2018-12-24T11:33:49.000Z</published>
    <updated>2018-12-24T11:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>项目地址： <a href="https://github.com/Clayeee/Server-Port-Scan-Tool" target="_blank" rel="noopener">https://github.com/Clayeee/Server-Port-Scan-Tool</a></p>          </div><a id="more"></a><p>Tool Name : Server Port Scan Tools<br>Version   : v 0.1.0<br>Developer : Claye<br>E-mail    : <a href="mailto:1269575798@qq.com" target="_blank" rel="noopener">1269575798@qq.com</a><br>Date      : 18/12/24</p><p><img src="/images/scan.png" alt="index"></p><h1 id="Server-Port-Scan-Tool"><a href="#Server-Port-Scan-Tool" class="headerlink" title="Server-Port-Scan-Tool"></a>Server-Port-Scan-Tool</h1><p>服务端基于Node.js开发，可扫描公网/内网服务器开放端口，外网处理速度2分钟，内网处理速度20秒。</p><h3 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点</h3><ul><li>非阻塞I/O操作，高并发处理</li><li>支持公网/内网端口扫描</li><li>可选择多种扫描模式</li><li>自动解析域名</li><li>搭建过程简单</li></ul><h3 id="服务器搭建教程"><a href="#服务器搭建教程" class="headerlink" title="服务器搭建教程"></a>服务器搭建教程</h3><ol><li>将端口扫描工具下载至本地，解压缩</li><li>下载 <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">node.js</a> 环境</li><li>安装服务器依赖，执行<code>npm install express</code></li><li>终端切换至工具所在文件夹，执行<code>node server.js</code></li><li>浏览器访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></li></ol><h3 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├─lib               # 引用文件</span><br><span class="line">│  ├─bootstrap        # bootstrap环境</span><br><span class="line">│  ├─index.js         # 前台数据处理，Ajax数据交互脚本</span><br><span class="line">│  ├─index.css        # 前端样式脚本</span><br><span class="line">│  ├─jquery-3.3.1.min.js # jquery脚本文件</span><br><span class="line">│  └─scan.js          # 端口扫描模块</span><br><span class="line">├─node_modules      # nodejs模块</span><br><span class="line">│  └─express          # express框架</span><br><span class="line">├─src               # 素材文引用文件夹</span><br><span class="line">│  ├─tittle.png       # index页面Logo</span><br><span class="line">│  └─tool.zip         # 内网扫描工具（包含全环境）</span><br><span class="line">├─favicon.ico       # 浏览器标签图标</span><br><span class="line">├─index.html        # 前台页面（8080端口默认起始页）</span><br><span class="line">├─README.md         # 说明文档</span><br><span class="line">├─server.js         # 服务器模块</span><br><span class="line">└─package-lock.json # nodejs包依赖配置文件</span><br></pre></td></tr></table></figure><h3 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3><blockquote><p>E-mail：<a href="mailto:1269575798@qq.com" target="_blank" rel="noopener">1269575798@qq.com</a></p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;项目地址： &lt;a href=&quot;https://github.com/Clayeee/Server-Port-Scan-Tool&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Clayeee/Server-Port-Scan-Tool&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt;
    
    </summary>
    
      <category term="node.js" scheme="http://www.xucha0.cn/categories/node-js/"/>
    
    
      <category term="node" scheme="http://www.xucha0.cn/tags/node/"/>
    
      <category term="express" scheme="http://www.xucha0.cn/tags/express/"/>
    
      <category term="端口扫描" scheme="http://www.xucha0.cn/tags/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>Javascript事件</title>
    <link href="http://www.xucha0.cn/Javascript%E4%BA%8B%E4%BB%B6/"/>
    <id>http://www.xucha0.cn/Javascript事件/</id>
    <published>2018-12-18T11:03:30.000Z</published>
    <updated>2018-12-18T11:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>事件就是<code>文档</code>或<code>浏览器窗口</code>中发生的一些特定的交互瞬间。</p>          </div><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><hr><p>事件流描述的是从页面中接收事件的<strong>顺序</strong>。<br><a id="more"></a></p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>IE的事件流叫做事件冒泡，既事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点。</p><blockquote><p>事件由内向外进行触发</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Event<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击<div>元素，事件冒泡顺序为：<code>&lt;div&gt; -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; document</code>。</div></p><blockquote><p> 所有现代浏览器都支持事件冒泡，但在具体实现上有一些差别</p></blockquote><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>事件捕获是指不太具体的节点更早接收到事件，而最具体的节点应该最后接收事件，</p><blockquote><p>事件由外向内进行触发</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Event<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击<div>元素，事件冒泡顺序为：<code>document -&gt; &lt;html&gt; -&gt; &lt;body&gt; -&gt; &lt;div&gt;</code>。</div></p><blockquote><p> 老版本浏览器不支持，一般不使用</p></blockquote><h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><p>事件流的三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Event<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事件流顺序为：<code>document -&gt; &lt;html&gt; -&gt; &lt;body&gt; -&gt; &lt;div&gt; -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; document</code></p><blockquote><p><code>document -&gt; &lt;html&gt; -&gt; &lt;body&gt;</code>为事件捕获阶段</p><p><div>为处于目标阶段</div></p><p><code>&lt;div&gt; -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; document</code>为事件冒泡阶段</p></blockquote><p><strong>事件触发元素被认为是事件冒泡的一部分，事件捕获阶段不会接收到事件</strong></p><h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><hr><p>响应某个事件的函数叫做事件处理程序，事件处理程序的名字以<code>“on”</code>开头。</p><h4 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h4><p>某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的<code>HTML特性</code>来指定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--将onclick事件绑定至input标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert('Hi')"</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>不能够使用未转义字符，例如：“ ‘ &lt; &gt; &amp; 等</p></blockquote><p>通过<code>event</code>变量可以直接访问时间对象，<code>this</code>表示当前标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--输出 "click"--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(event.type)"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--输出 "Click Me"--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert(this.value)"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h4><p>将函数赋值给一个事件处理程序属性。</p><blockquote><p>优点：简单、跨浏览器优势。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);          <span class="comment">// "myBtn" this指向当前标签元素</span></span><br><span class="line">&#125;;</span><br><span class="line">btn.onclick = <span class="literal">null</span>;          <span class="comment">// 删除DOM0级事件</span></span><br></pre></td></tr></table></figure><h4 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h4><ol><li><code>addEventListener(&quot;event&quot;, function, boolean)</code>方法：指定事件处理程序。</li><li><code>removeEventListener(&quot;event&quot;, function, boolean)</code>方法：删除事件处理程序。</li></ol><blockquote><p><code>event</code>：事件名称。</p><p><code>function</code>：事件处理函数。</p><p><code>boolean</code>：<code>true</code>——捕获阶段调用，<code>false</code>——冒泡阶段调用。</p></blockquote><p><em>可以为一个事件添加多个事件处理程序，按顺序执行。</em></p><blockquote><p>使用<code>addEventListener()</code>方法添加的事件处理程序只能用<code>removeEventListener()</code>方法删除。</p><p>所以当<code>addEventListener()</code>方法添加事件处理程序为匿名函数的时候，removeEventListener()方法无效。</p></blockquote><h4 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h4><ol><li><code>attachEvent(onEvent, function)</code>：指定事件处理程序。</li><li><code>detachEvent(onEvent, function)</code>：删除事件处理程序。</li></ol><blockquote><p>事件处理程序作用域为全局作用域，所以<strong>this</strong>指向<strong>window</strong>对象。</p></blockquote><p><em>可以为一个事件添加多个事件处理程序，按相反顺序执行。</em></p><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><hr><p>当触发DOM上的某个事件时，会产生一个时间对象event，这个对象中包含着所有与事件有关的信息。</p><h4 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h4><p>兼容DOM的浏览器会将一个<code>event</code>对象传入到事件处理程序中。</p><ul><li><code>event</code>对象属性及方法：</li></ul><table><thead><tr><th>属性/方法</th><th>类型</th><th>读/写</th><th>说明</th></tr></thead><tbody><tr><td><code>bubbles</code></td><td>Boolean</td><td>只读</td><td>表明事件是否冒泡</td></tr><tr><td><code>cancelable</code></td><td>Boolean</td><td>只读</td><td>表明是否可以取消事件的默认行为</td></tr><tr><td><code>currentTarget</code></td><td>Element</td><td>只读</td><td>其事件处理程序当前正在处理事件的那个元素</td></tr><tr><td><code>defaultPrevented</code></td><td>Boolean</td><td>只读</td><td><code>true</code>表示已经调用了<code>preventDefault()</code>方法（DOM3）</td></tr><tr><td><code>detail</code></td><td>Integer</td><td>只读</td><td>与事件相关的细节信息</td></tr><tr><td><code>eventPhase</code></td><td>Integer</td><td>只读</td><td>调用事件处理程序的阶段：<code>1</code>表示捕获阶段，<code>2</code>表示“处于目标”，<code>3</code>表示冒泡阶段</td></tr><tr><td><code>preventDefault()</code></td><td>Function</td><td>只读</td><td>取消事件的默认行为。如果<code>cancelable</code>是<code>true</code>，则可以使用这个方法</td></tr><tr><td><code>stopImmdiatePropagation()</code></td><td>Function</td><td>只读</td><td>取消事件的进一步捕获或冒泡，同时阻止任何时间处理程序被调用（DOM3）</td></tr><tr><td><code>stopPropagation()</code></td><td>Function</td><td>只读</td><td>取消时间的进一步捕获或冒泡。如果<code>bubbles</code>为<code>true</code>，则可使用这个方法</td></tr><tr><td><code>target</code></td><td>Element</td><td>只读</td><td>事件的目标</td></tr><tr><td><code>trusted</code></td><td>Boolean</td><td>只读</td><td>为<code>true</code>表示事件是浏览器生成的。为<code>false</code>表示事件是由开发人员通过<code>JavaScript</code>创建的（DOM3）</td></tr><tr><td><code>type</code></td><td>String</td><td>只读</td><td>被触发的事件类型</td></tr><tr><td><code>view</code></td><td>AbstractView</td><td>只读</td><td>与事件关联的抽象视图。等同于发生事件的<code>window</code>对象</td></tr></tbody></table><h4 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h4><p><strong>使用DOM0级方法</strong>：<code>event</code>对象作为<code>window</code>对象的一个属性。</p><ul><li><code>event</code>对象属性和方法：</li></ul><table><thead><tr><th>属性/方法</th><th>类型</th><th>读/写</th><th>说明</th></tr></thead><tbody><tr><td>cancelBubble</td><td>Boolean</td><td>读/写</td><td>默认值为false，但将其设置为true就可以取消事件冒泡（与DOM中的<code>stopPropagation()</code>方法相同）</td></tr><tr><td>returnValue</td><td>Boolean</td><td>读/写</td><td>默认值为true，但将其设置为false就可以取消事件的默认行为（与DOM中的<code>preventDefault()</code>方法相同）</td></tr><tr><td>srcElement</td><td>Element</td><td>只读</td><td>事件的目标（与DOM中的<code>target</code>属性相同）</td></tr><tr><td>type</td><td>String</td><td>只读</td><td>被触发的事件的类型</td></tr></tbody></table><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><hr><p><strong>DOM3级事件类型：</strong></p><ul><li>UI事件：当用户与页面上的元素交互时触发。</li><li>焦点事件：当元素获得或失去焦点时触发。</li><li>鼠标事件：当用户通过鼠标在页面上执行操作时触发。</li><li>滚轮事件：当使用鼠标滚轮时触发。</li><li>文本事件：当在文档中输入文本时触发。</li><li>键盘事件：当用户通过键盘在页面上执行操作时触发。</li><li>合成事件：当为IME输入字符事触发。</li><li>变动事件：当底层DOM结构发生变化时触发。</li></ul><h4 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h4><ul><li><strong><code>load</code></strong>：当页面完全加载后在<code>window</code>上面触发，当所有框架都加载完毕时在框架集上面触发，当图像加载完毕时在<img>元素上面触发，当嵌入的内容加载完毕时在<object>元素上面触发。</object></li><li><strong><code>unload</code></strong>：当页面完全卸载后在<code>window</code>上面触发，当所有框架都卸载后在框架集上面触发，当嵌入内容卸载后在<object>元素上面触发。</object></li><li><strong><code>abort</code></strong>：当用户停止下载过程时，如果嵌入的内容没有加载完，则在<object>元素上面触发。</object></li><li><strong><code>error</code></strong>：当发生<code>JavaScript</code>错误时在<code>window</code>上面触发，当无法加载图像时在<img>上触发，当无法加载嵌入内容时在<object>上触发，当有一个或多个框架无法加载时在框架集上触发。</object></li><li><strong><code>select</code></strong>：当用户选择文本框中的一个或多个字符时触发。</li><li><strong><code>resize</code></strong>：当窗口或框架大小变化时在<code>window</code>或框架上面触发。</li><li><strong><code>scroll</code></strong>：当用户滚动带滚动条的元素中的内容时，在该元素上面触发。<body>元素中包含所加载页面的滚动条。</body></li></ul><blockquote><p>以上事件在DOM2中都归为HTML事件。</p></blockquote><h4 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h4><p>在页面元素获得或失去元素焦点时触发。</p><ul><li><code>blur</code>：在元素失去焦点时触发，这个事件不会冒泡。</li><li><code>DOMFocusIn</code>：在元素获得焦点时触发，与HTML事件的focus等价，但它冒泡。[仅Opera支持]</li><li><code>DOMFocusOut</code>：在元素失去焦点时触发，与HTML事件的focus等价，但它冒泡。[仅Opera支持]</li><li><code>focus</code>：在元素获得焦点时触发。这个事件不会冒泡。</li><li><code>focusin</code>：在元素获得焦点时触发。与HTML事件的<code>focus</code>等价，但它冒泡。</li><li><code>focusout</code>：在元素失去焦点时触发。这个事件是HTML事件<code>blur</code>的通用版本。</li></ul><h4 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h4><ul><li><code>click</code>：在用户单击鼠标或是按下回车键时触发。</li><li><code>dbclick</code>：用户双击鼠标触发，DOM3纳入标准</li><li><code>mousedown</code>：用户按下任意鼠标按钮触发。</li><li><code>mouseenter</code>：鼠标光标从元素外部首次移动到元素范围之内触发，这个事件不冒泡。</li><li><code>mouseleave</code>：在位于元素上方的鼠标光标移动到元素之外触发。改时间不冒泡，而且在光标移动到子后代元素也不会触发。</li><li><code>mousemove</code>：当鼠标指针在元素内部移送时重复的触发。</li><li><code>mouseout</code>：在鼠标指针位于一个元素的上方，然后用户将其移入另一个元素时触发。</li><li><code>mouseover</code>：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。</li><li><code>mouseup</code>：在用户释放鼠标按钮时触发。</li></ul><p>只有相继触发<code>mousedown</code>和<code>mouseup</code>事件，才会触发<code>click</code>事件，只有触发两次<code>click</code>事件，才会触发<code>dbclick</code>事件。触发顺序如下：</p><ol><li><code>mousedown</code></li><li><code>mouseup</code></li><li><code>click</code></li><li><code>moisedown</code></li><li><code>mouseup</code></li><li><code>click</code></li><li><code>dbclick</code></li></ol><h5 id="1-客户端坐标位置"><a href="#1-客户端坐标位置" class="headerlink" title="1. 客户端坐标位置"></a>1. 客户端坐标位置</h5><p><code>clientX</code>和<code>cliickY</code>分别表示鼠标指针在浏览器窗口中的水平和垂直坐标。</p><h5 id="2-页面坐标位置"><a href="#2-页面坐标位置" class="headerlink" title="2. 页面坐标位置"></a>2. 页面坐标位置</h5><p><code>pageX</code>和<code>pageY</code>分别表示鼠标指针在页面中的水平和垂直坐标。</p><blockquote><p>如果页面没有被滚动，则<code>pageX</code>、<code>pageY</code>的值与<code>clientX</code>、<code>clientY</code>的坐标相同。</p></blockquote><h5 id="3-屏幕坐标位置"><a href="#3-屏幕坐标位置" class="headerlink" title="3.屏幕坐标位置"></a>3.屏幕坐标位置</h5><p><code>screenX</code>和<code>screenY</code>分别表示鼠标指针在屏幕位置中的水平和垂直坐标。</p><h5 id="4-修改键"><a href="#4-修改键" class="headerlink" title="4.修改键"></a>4.修改键</h5><p><code>shift</code>、<code>Ctrl</code>、<code>Alt</code>和<code>Meta</code>（<code>win</code>或<code>cmd</code>）键分别对应<code>shiftKey</code>、<code>ctrlKey</code>、<code>altKey</code>、<code>metaKey</code>。当这些属性值为<code>true</code>时，就表示他们所对应的按键被按下。</p><h4 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h4><ul><li><code>keydown</code>：当用户按下按键上的任意键触发，如果按住不放则会重复触发。</li><li>keypress：当用户按下按键上的字符键触发，如果按住不放则会重复触发。</li><li>keyup：当用户释放键盘上的键时触发。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;事件就是&lt;code&gt;文档&lt;/code&gt;或&lt;code&gt;浏览器窗口&lt;/code&gt;中发生的一些特定的交互瞬间。&lt;/p&gt;
          &lt;/div&gt;
&lt;h3 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;事件流描述的是从页面中接收事件的&lt;strong&gt;顺序&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.xucha0.cn/categories/JavaScript/"/>
    
    
      <category term="Web前端" scheme="http://www.xucha0.cn/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://www.xucha0.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="DOM" scheme="http://www.xucha0.cn/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>DOM事件扩展</title>
    <link href="http://www.xucha0.cn/DOM%E4%BA%8B%E4%BB%B6%E6%89%A9%E5%B1%95/"/>
    <id>http://www.xucha0.cn/DOM事件扩展/</id>
    <published>2018-12-04T08:47:04.000Z</published>
    <updated>2018-12-04T08:47:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="选择符API（Selectors-API）"><a href="#选择符API（Selectors-API）" class="headerlink" title="选择符API（Selectors API）"></a>选择符API（Selectors API）</h3><h4 id="querySelector-方法"><a href="#querySelector-方法" class="headerlink" title="querySelector();方法"></a><code>querySelector();</code>方法</h4><p><code>querySelector();</code>方法：接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到返回<code>null</code>。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过元素名</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">"body"</span>);</span><br><span class="line"><span class="comment">// 通过ID</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">"#myDiv"</span>);</span><br><span class="line"><span class="comment">// 通过类名</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">".btn"</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>通过<code>Document</code>类型调用该方法时，会在文档元素的范围内查找匹配的元素。</p><p>通过<code>Element</code>类型调用该方法时，只会在该元素的后代元素范围内查找匹配元素。</p></blockquote><h4 id="querySelectorAll-方法"><a href="#querySelectorAll-方法" class="headerlink" title="querySelectorAll();方法"></a><code>querySelectorAll();</code>方法</h4><p><code>querySelectorAll();</code>方法 ：接收一个CSS选择符，返回一个NodeList实例。</p><blockquote><p>使用方法与querySelector();方法大致相同</p></blockquote><h4 id="matchesSelector-方法"><a href="#matchesSelector-方法" class="headerlink" title="matchesSelector();方法"></a><code>matchesSelector();</code>方法</h4><p><code>matchesSelector();</code>方法：接收一个CSS选择符，如果调用元素与该选择符匹配，返回<code>true</code>。</p><!--浏览器支持性不是很好--><h3 id="元素遍历（Element-Traversal-API）"><a href="#元素遍历（Element-Traversal-API）" class="headerlink" title="元素遍历（Element Traversal API）"></a>元素遍历（Element Traversal API）</h3><p><code>Element Traversal API</code>为<code>DOM</code>元素添加的5个属性：</p><ul><li><code>childElementCount</code>：返回子元素（不包括文本节点和注释）的个数。</li><li><code>firstElementChild</code>：指向第一个子元素；<code>firstChild</code>的元素版</li><li><code>lastElementChild</code>：指向最后一个子元素；<code>lastChild</code>的元素版</li><li><code>previousElementSibling</code>：指向前一个同辈元素；<code>previousSibling</code>元素版</li><li><code>nextElementSibling</code>：指向后一个同辈元素；<code>nextSibling</code>元素版</li></ul><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="与类相关的扩容："><a href="#与类相关的扩容：" class="headerlink" title="与类相关的扩容："></a>与类相关的扩容：</h4><p><code>getElementsByClassName(classnames);</code>方法：传入一个或多个类名为参数，返回对象为NodeList。</p><p><code>classList</code>属性：获取元素所有的class名，并以数组的形式返回。</p><ul><li>add(value)：将给定的字符串添加到列表中，如果已存在则不添加。</li><li>contains(value)：表示列表中是否存在给定的值，如果存在返回true</li><li>remove(value)：从列表中删除给定的字符串</li><li>toggle(value)：如果列表有给定的值，则删除；如果没有，则添加</li></ul><h4 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h4><p><code>focus();</code>方法：使元素获取焦点</p><p><code>document.activeElement</code>属性：返回DOM中当前获得了焦点的元素，没有返回<code>null</code></p><p><code>document.hasFocus();</code>方法：判断元素是否获得了焦点</p><h4 id="HTMLDocument的变化"><a href="#HTMLDocument的变化" class="headerlink" title="HTMLDocument的变化"></a>HTMLDocument的变化</h4><h5 id="readyState属性："><a href="#readyState属性：" class="headerlink" title="readyState属性："></a><code>readyState</code>属性：</h5><p><code>document.readyState</code>属性：检查文档是否加载完毕。</p><ul><li><code>loading</code>：正在加载文档</li><li><code>complete</code>：已经加载完文档</li></ul><h5 id="兼容模式："><a href="#兼容模式：" class="headerlink" title="兼容模式："></a>兼容模式：</h5><p><code>document.readyState</code>属性：区分渲染页面的模式是标准的还是混杂的</p><ul><li><code>CSSCompt</code>：标准模式</li><li><code>BackCompt</code>：混杂模式</li></ul><h5 id="head属性："><a href="#head属性：" class="headerlink" title="head属性："></a>head属性：</h5><p><code>document.head</code>属性：引用文档<body>元素的补充。</body></p><blockquote><p>仅Chrome和Safari5支持</p></blockquote><h4 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h4><p><code>document.charset</code>属性：设置文档字符集属性，等同于<meta>标签下的<code>charset</code>属性。</p><blockquote><p>例：<code>document.charset = &#39;UTF-8&#39;</code></p></blockquote><p><code>document.defaultCharset</code>属性：根据默认浏览器和操作系统设置，当前文档的默认字符集。</p><h4 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h4><p>HTML5可以为元素添加非标准属性，但是要添加前缀<code>data-</code>。</p><p>访问和定义自定义属性的值：元素的<code>dataset</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">data-myName</span>=<span class="string">"Xuchao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"#myDiv"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取自定义属性的值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> data = div.dataset.myName;    <span class="comment">//data="Xuchao"</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置自定义属性的值</span></span></span><br><span class="line"><span class="javascript">    div.datasetmyName = <span class="string">"Chaoge"</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h4><h5 id="innerHTML属性："><a href="#innerHTML属性：" class="headerlink" title="innerHTML属性："></a><code>innerHTML</code>属性：</h5><p>用于子元素创建新的DOM树或返回子节点对应的HTML标记。</p><ul><li>读模式：会返回子元素下所有的HTML标记。</li><li>写模式：会根据指定的值创建新的DOM树，替换所有的子节点。</li></ul><blockquote><p>设置<code>innerHTML</code>后在从中读取HTML字符串，会得到与设置时不一样的值。原因在于用于返回的字符串是根据原始HTML字符串创建的DOM树经过序列化之后的结果。</p></blockquote><p><strong>插入<script>标签并不能执行脚本</strong></p><p><code>script</code>元素被认为是“<strong>无作用域的元素</strong>”，如果想要插入脚本并执行，必须在前面添加一个“<strong>有作用域的元素</strong>”，例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.innerHTML = <span class="string">"_&lt;script defer&gt;alert("</span>hi<span class="string">");&lt;\/script&gt;"</span>;</span><br><span class="line">div.innerHTML = <span class="string">"&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;script defer&gt;alert("</span>hi<span class="string">");&lt;\/script&gt;"</span>;</span><br><span class="line">div.innerHTML = <span class="string">"&lt;input type=\"hidden\"&gt;&lt;script defer&gt;alert("</span>hi<span class="string">");&lt;\/script&gt;"</span>;<span class="comment">//首选</span></span><br></pre></td></tr></table></figure><p><strong>不支持</strong>的<code>innerHTML</code>属性的元素：<col>、<colgroup>、<frameset>、<head>、<html>、<style>、<table>、<tbody>、<thead>、<tfoot>、<tr>。</p><h5 id="outerHTML属性："><a href="#outerHTML属性：" class="headerlink" title="outerHTML属性："></a><code>outerHTML</code>属性：</h5><p>调用元素及子节点HTML标签或指定HTML字符串创建新的DOM树。</p><blockquote><p>与<code>innerHTML</code>差异：<code>innerHTML</code>仅操作子元素，而<code>outerHTML</code>操作元素本身及子元素</p></blockquote><h5 id="insertAdjacentHTML-方法："><a href="#insertAdjacentHTML-方法：" class="headerlink" title="insertAdjacentHTML()方法："></a><code>insertAdjacentHTML()</code>方法：</h5><p><code>insertAdjacentHTML(place, HTMLtext)</code>：在指定位置<code>(place)</code>插入HTML文本<code>(HTMLtext)</code>。</p><p>指定位置参数<code>[place]</code>必须是以下值之一：</p><ul><li><code>beforebegin</code>：在当前元素之前插入一个相邻的同辈元素。</li><li><code>afterbegin</code>：在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素。</li><li><code>beforeend</code>：在当前元素之下插入一个新的子元素或在第一个子元素之后再插入新的子元素。</li><li><code>afterend</code>：在当前元素之后插入一个紧邻的同辈元素。</li></ul><h5 id="内存与性能问题："><a href="#内存与性能问题：" class="headerlink" title="内存与性能问题："></a>内存与性能问题：</h5><p>每使用以上三种方法替换掉元素时，元素绑定的事件及处理程序在内存中并没有及时删除，如果以上三种方法使用次数过多，会导致内存与浏览器性能出现问题。</p><blockquote><p>解决办法：</p><ul><li>手工删除要被替换元素的所有事案件处理程序和Javascript对象属性。</li><li>合理使用插入标记方法。</li></ul></blockquote><h4 id="scrollIntoView-方法："><a href="#scrollIntoView-方法：" class="headerlink" title="scrollIntoView()方法："></a><code>scrollIntoView()</code>方法：</h4><p>实现滚动页面，参数为一个布尔值。</p><ul><li>如果传入<code>true</code>或者不传入值，则当事件触发时这个元素的顶部被滚动至浏览器的顶部。</li><li>如果传入<code>false</code>，则当事件触发时这个元素尽可能的被显示在浏览器窗口中（<strong>可能是</strong>底部与浏览器底部持平）。</li></ul><h3 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h3><p>浏览器厂商为DOM提供的专有扩展——非标准。</p><h4 id="children属性"><a href="#children属性" class="headerlink" title="children属性"></a>children属性</h4><p><code>HTMLCollection</code>实例，只包含元素中同样还是元素的子节点，除此之外和<code>childNodes</code>没有区别。</p><blockquote><p>兼容各浏览器早期版本</p></blockquote><h4 id="contains-方法"><a href="#contains-方法" class="headerlink" title="contains()方法"></a>contains()方法</h4><p>判断某个节点是不是另一个节点的后代。调用contains()方法的应该是<strong>祖先节点</strong>。也就是搜索开始的节点。</p><p>接收一个参数，即需要检测的后代节点，返回一个布尔值。</p><h5 id="DOM3中compareDocumentPosiaion-方法"><a href="#DOM3中compareDocumentPosiaion-方法" class="headerlink" title="DOM3中compareDocumentPosiaion()方法"></a>DOM3中<code>compareDocumentPosiaion()</code>方法</h5><p>用来判断节点间的关系，与<strong>contains()</strong>方法大致相同，返回一个<code>位掩码</code>：</p><table><thead><tr><th style="text-align:center">掩码</th><th>节点关系</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>无关（给定的节点不在当前文档中）</td></tr><tr><td style="text-align:center">2</td><td>居前（给定的节点在DOM树中位于参考节点之前）</td></tr><tr><td style="text-align:center">4</td><td>居后（给定的节点在DOM树中位于参考节点之后）</td></tr><tr><td style="text-align:center">8</td><td>包含（给定的节点是参考节点的祖先）</td></tr><tr><td style="text-align:center"><strong>16</strong></td><td><strong>被包含（给定节点是参考阶段的后代）</strong></td></tr></tbody></table><h4 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h4><h5 id="innerText属性："><a href="#innerText属性：" class="headerlink" title="innerText属性："></a><code>innerText</code>属性：</h5><p>读取和写入节点及子节点中的文本。</p><ul><li>读取时：将子文档树中所有文本拼接起来输出。</li><li>写入时：删除元素所有子节点，插入包含相应值的文本节点。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a String!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Team 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Team 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Team 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">div = <span class="built_in">document</span>.querySelector(<span class="string">"#myDiv"</span>);</span></span><br><span class="line"><span class="javascript">txt = div.innerText;   <span class="comment">// txt = "This is a String! Team 1 Team 2 Team 3"</span></span></span><br><span class="line"><span class="javascript">div.innerText = <span class="string">"Hello World!"</span>;   <span class="comment">//&lt;div&gt;Hello World!&lt;/div&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>innerText</code>会将所有字符串按文本格式解析，并不能解析HTML标签，而是会将HTML标签解析成字符串。</p></blockquote><p>利用<code>innerText</code>属性可以过滤掉HTML标签，有效防止XSS跨站攻击。过滤方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.innerText = div.innerText;</span><br></pre></td></tr></table></figure><h5 id="outerText属性："><a href="#outerText属性：" class="headerlink" title="outerText属性："></a><code>outerText</code>属性：</h5><ul><li>读取时：与<code>innerText</code>属性作用相同。</li><li>写入时：替换整个元素。</li></ul><h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><ul><li><code>scrollIntoViewIfNeeded(alignCenter)</code>：只在当前元素在窗口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让他可见，如果当前元素视口可见，则什么都不做。居中参数为<code>布尔值</code>。</li><li><code>scrollByLines(lineCount)</code>：将元素内容滚动到指定行高。参数可以是正值和负值。</li><li><code>scrollByPages(pageCount)</code>：将元素的内容滚动到指定的页面高度，具体高度由元素高度决定。</li></ul><blockquote><p>仅Chrome和Safari浏览器支持</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>Selectors API</strong>，定义了两个方法，既<code>querySelector()</code>和<code>querySelectorALL()</code>。</li><li><strong>Element Traversal</strong>，为DOM元素定义额外的属性，可以从一个元素跳到另一个元素。</li><li><strong>HTML5</strong>，为标准的DOM定义了很多扩展功能。</li></ul><hr></script></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;选择符API（Selectors-API）&quot;&gt;&lt;a href=&quot;#选择符API（Selectors-API）&quot; class=&quot;headerlink&quot; title=&quot;选择符API（Selectors API）&quot;&gt;&lt;/a&gt;选择符API（Selectors API）&lt;/h3&gt;&lt;h4 id=&quot;querySelector-方法&quot;&gt;&lt;a href=&quot;#querySelector-方法&quot; class=&quot;headerlink&quot; title=&quot;querySelector();方法&quot;&gt;&lt;/a&gt;&lt;code&gt;querySelector();&lt;/code&gt;方法&lt;/h4&gt;&lt;p&gt;&lt;code&gt;querySelector();&lt;/code&gt;方法：接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到返回&lt;code&gt;null&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.xucha0.cn/categories/JavaScript/"/>
    
    
      <category term="Web前端" scheme="http://www.xucha0.cn/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://www.xucha0.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="DOM" scheme="http://www.xucha0.cn/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>DOM事件对象</title>
    <link href="http://www.xucha0.cn/DOM%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.xucha0.cn/DOM事件对象/</id>
    <published>2018-11-28T02:08:09.000Z</published>
    <updated>2018-11-28T02:08:09.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>DOM节点层次，DOM事件类型</p>          </div><p>DOM是针对HTML和XML文档的一个API。</p><p><strong>IE中所有的DOM对象都是以COM对象的形式实现的</strong></p><h3 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h3><ul><li>DOM可以将任何HTML或XML文档描绘长城一个<strong>多层节点</strong>构成的结构。<a id="more"></a></li><li><p>每个节点拥有各自的<strong>特点</strong>、<strong>数据</strong>和<strong>方法</strong>，并与其他节点存在关系。</p></li><li><p><strong>文档节点</strong>是每个文档的<strong>根节点</strong>。在HTML文件中，文档节点只有一个子节点，既<html>元素，我们称之为<strong>文档元素</strong>。文档元素是文档最外层的元素，文档中其他元素都包含在文档元素中。</html></p></li></ul><p>每段标记都可以通过树中的一个节点表示。节点类型一共分为12种：</p><h4 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h4><blockquote><p>DOM1级定义了一个Node接口，该接口由<strong>DOM中所有的节点类型</strong>实现。<strong>除IE外</strong>其他浏览器都可访问Node类型，<strong>Javascript中所有的节点类型都继承自Node类型</strong>。</p></blockquote><p><code>nodeType</code>属性：每个节点都拥有该属性。</p><table><thead><tr><th>类型</th><th style="text-align:center">数值</th><th>说明</th></tr></thead><tbody><tr><td>Node.ELEMENT_NODE</td><td style="text-align:center">1</td><td>代表元素</td></tr><tr><td>Node.ATTERIBUTE_NODE</td><td style="text-align:center">2</td><td>代表属性</td></tr><tr><td>Node.TEXT_NODE</td><td style="text-align:center">3</td><td>代表元素或属性中的文本内容</td></tr><tr><td>Node.CDATA_SECTION_NODE</td><td style="text-align:center">4</td><td>代表文档中的CDATA部分</td></tr><tr><td>Node.ENTITY_REFERENCE_NODE</td><td style="text-align:center">5</td><td>代表实体引用</td></tr><tr><td>Node.ENTITY_NODE</td><td style="text-align:center">6</td><td>代表实体</td></tr><tr><td>Node.PROCESSING_INSTRUCTION_NODE</td><td style="text-align:center">7</td><td>代表处理指令</td></tr><tr><td>Node.COMMENT_NODE</td><td style="text-align:center">8</td><td>代表注释</td></tr><tr><td>Node.DOCUMENT_NODE</td><td style="text-align:center">9</td><td>道标整个文档（DOM树根节点）</td></tr><tr><td>Node.DOCUMENT_TYPE_NODE</td><td style="text-align:center">10</td><td>想为文档定义的实体提供接口</td></tr><tr><td>Node.DOCUMENT_FRAGENT_NODE</td><td style="text-align:center">11</td><td>代表轻量级的文档对象</td></tr><tr><td>Node.NOTATION_NODE</td><td style="text-align:center">12</td><td>代表dtd中声明的符号</td></tr></tbody></table><!--由于IE的兼容性问题，尽量使用数值代码进行比较--><h5 id="nodeName-和-nodeValue-属性："><a href="#nodeName-和-nodeValue-属性：" class="headerlink" title="nodeName 和 nodeValue 属性："></a><code>nodeName</code> 和 <code>nodeValue</code> 属性：</h5><ul><li><code>nodeName</code>：节点名称</li><li><code>nodeValue</code>：节点内容</li></ul><h5 id="节点关系："><a href="#节点关系：" class="headerlink" title="节点关系："></a>节点关系：</h5><p>子元素、父元素、兄弟元素。</p><p><strong><code>childNodes</code>属性</strong>：每一个节点都存在一个<code>childNodes</code>属性，其中保存着一个<code>NodeList类数组对象</code>，保存一组有序的节点，可以通过位置访问这些节点。</p><blockquote><p>NodeList对象是基于DOM结构动态执行查询的结果，DOM结构的变化能够自动反映在NodeList对象中。该对象也想数组一样具有length属性。</p></blockquote><p><strong><code>parentNode</code>属性</strong>：该属性指向文档树中的父结点。</p><blockquote><p>NodeList列表中的每一个节点都有nextSibling属性和previousSibling属性用来访问该节点的下一个节点和上一个节点</p></blockquote><blockquote><p>父节点的firstChild属性和lastChild属性分别指向NodeList列表中的第一个和最后一个节点。</p></blockquote><p><strong><code>hasChildNodes()</code>方法</strong>：该节点下是否拥有子节点。</p><p><strong><code>ownerDocument</code>属性</strong>：指向表示整个文档的文档节点，既根节点。</p><h5 id="操作节点："><a href="#操作节点：" class="headerlink" title="操作节点："></a>操作节点：</h5><p><strong><code>appendChild( newNode )</code>方法</strong>：向<code>childNodes</code>列表末尾添加一个节点。</p><blockquote><p> 如果将childNodes列表中的节点使用appendChild()方法，则会将该节点移动至该列表末尾</p></blockquote><p><strong><code>insertBefore( newNode, ReferenceNode)</code>方法</strong>：在参照节点前将新节点插入进<code>childNodes</code>列表。</p><blockquote><p> 如果参照节点为NULL，则该方法与appendChild()作用一致</p></blockquote><p><strong><code>replaceChild( newNode, oldNode )</code>方法</strong>：用新节点替换掉旧的节点。</p><p><strong><code>removeChild( Node )</code>方法</strong>：从NodeList列表中删除一个节点，并返回这个被删除的节点。</p><h5 id="其他方法："><a href="#其他方法：" class="headerlink" title="其他方法："></a>其他方法：</h5><p><strong><code>cloneNode( Boolean )</code>方法</strong>：复制一个节点，参数为是否进行深复制。</p><blockquote><p>当参数为true时，复制节点及其整个子节点树。为false时，只复制节点本身。</p></blockquote><p><strong><code>normalize()</code>方法</strong>：处理文档树中的文本节点。</p><h4 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h4><p><code>Javascript</code>中通过<code>Document</code>类型表示文档。在浏览器中，<code>document</code>对象是<code>HTMLDocument</code>的一个实例，表示整个HTML页面。</p><blockquote><p>document对象是window对象的一个属性，因此可以将它当做一个全局对象来访问</p></blockquote><p><code>Document</code>节点的<strong>特征</strong>：</p><ul><li><code>nodeType</code>的值为<code>9</code></li><li><code>nodeName</code>的值为<code>“#document”</code></li><li><code>nodeValue</code>的值为<code>null</code></li><li><code>parentNode</code>的值为<code>null</code></li><li><code>ownerDocument</code>的值为<code>null</code></li><li>子节点：<code>DocumentType</code>（最多一个），<code>Element</code>（最多一个），<code>ProcessingInstruction</code>，<code>Comment</code></li></ul><h5 id="文档子节点："><a href="#文档子节点：" class="headerlink" title="文档子节点："></a>文档子节点：</h5><p>   <code>document.documentElement</code>属性：指向文档中<html>元素</html></p><p>   <code>childNodes</code>列表：指向所有子节点</p><p>   <code>document.body</code>属性：指向<body>元素</body></p><p>   <code>document.doctype</code>属性：访问<code>&lt;!DOCTYPE&gt;</code>标签内的信息 ( 浏览器支持不一致，作用有限 )</p><h5 id="文档信息："><a href="#文档信息：" class="headerlink" title="文档信息："></a>文档信息：</h5><p>   <code>document.tittle</code>属性：读或写<code>HTML</code>文档标题</p><p>   <code>document.URL</code>属性：获取地址栏中的URL</p><p>   <code>document.domain</code>属性：获取页面域名</p><p>   <code>document.referrer</code>属性：链接当前页面的页面URL，如果没有则为空字符串</p><blockquote><p>这四个属性只有<code>tittle</code>和<code>domain</code>是可设置的，当页面<strong>URL为二级域名</strong>时，<code>domian</code>的属性值<strong>必须是该域名的一级域名</strong></p></blockquote><h5 id="查找元素："><a href="#查找元素：" class="headerlink" title="查找元素："></a>查找元素：</h5><p>   <code>document.getElementById(&quot;ID&quot;);</code>：通过ID获取标签  <strong>单个元素</strong></p><p>   <code>document.getElementsByTagName(&quot;Tagname&quot;);</code>：通过标签名获取标签  <strong>动态类数组对象</strong></p><p>   <code>document.getElementByName(&quot;Name&quot;);</code>：通过Name属性名称获取标签  <strong>只有HTMLDocument类型标签才有的方法，返回的也是一个动态类数组对象</strong></p><h5 id="特殊集合："><a href="#特殊集合：" class="headerlink" title="特殊集合："></a>特殊集合：</h5><p>   <code>document.anchors</code>：包含所有带<code>name</code>属性的<a>元素</a></p><p>   <code>document.applets</code>：包含所有<applet>元素   <strong>不建议使用</strong></applet></p><p>   <code>document.forms</code>：包含所有<form>元素，与<code>document.getElementsByTagName(&quot;form&quot;);</code>等价</form></p><p>   <code>document.images</code>：包含所有<image>元素，与<code>document.getElementsByTagName(&quot;image&quot;);</code>等价</image></p><p>   <code>document.links</code>：包含文档中所有带<code>href</code>特性的<a>元素</a></p><h5 id="DOM一致性检测："><a href="#DOM一致性检测：" class="headerlink" title="DOM一致性检测："></a>DOM一致性检测：</h5><p>   <code>document.implementation.hasFeature(&quot;function&quot;, &quot;Version&quot;);</code> ：检测DOM功能对应的版本号，返回布尔值</p><h5 id="文档写入："><a href="#文档写入：" class="headerlink" title="文档写入："></a>文档写入：</h5><p>   <code>document.write(&quot;Str&quot;);</code>：原样输出字符串内容</p><p>   <code>document.writeln(&quot;Str&quot;);</code>：在字符串内容末尾添加一个‘<code>\n</code>’，并输出</p><blockquote><p> 如果文档结束后加载document.write，则页面会被重写</p></blockquote><p>   <code>document.open();</code>：打开网页的输出流</p><p>   <code>document.close();</code>：关闭网页的输出流</p><h4 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h4><p>用于表现XML或HTML元素，提供对元素的标签名，子节点及特性的访问。</p><p><code>Element节点</code>具有以下<strong>特征</strong>：</p><ul><li><code>nodeType</code>的值为<code>1</code></li><li><code>nodeName</code>的值为<code>元素的标签名</code></li><li><code>nodeValue</code>的值为<code>null</code></li><li><code>parentNode</code>可能是<code>Doucment</code>或<code>Element</code></li><li>子节点：<code>Element</code>、<code>Text</code>、<code>Comment</code>、<code>ProcessingInstruction</code>、<code>CDATASection</code>或<code>EntityReference</code></li></ul><blockquote><p>TagName == nodeName</p></blockquote><h5 id="HTML元素："><a href="#HTML元素：" class="headerlink" title="HTML元素："></a>HTML元素：</h5><p>特性：<code>id</code>，<code>tittle</code>，<code>lang</code>，<code>dir</code>，<code>classname</code></p><h5 id="取得特性："><a href="#取得特性：" class="headerlink" title="取得特性："></a>取得特性：</h5><p>getAttribute(“attr”);：取得特性的值，也可以是自定义特性</p><blockquote><p><strong>style</strong>:</p><p>以<code>属性值</code>访问则返回一个<strong>对象</strong>；</p><p>以<code>getAttribute()</code>方式访问返回<strong>CSS文本</strong>；</p></blockquote><blockquote><p><strong>onclick等事件处理程序</strong>：</p><p>以<code>属性值</code>访问则返回一个<strong>Javascript函数</strong>；</p><p>以<code>getAttribute()</code>方式访问返回<strong>代码字符串</strong>；</p></blockquote><h5 id="设置特性："><a href="#设置特性：" class="headerlink" title="设置特性："></a>设置特性：</h5><p><code>setAttribute(&quot;attr&quot;, &quot;value&quot;);</code>：设置特性，如果特性存在则覆盖，如果不存在则新建</p><p><code>removeAttribute(&quot;attr&quot;);</code>：删除指定特性及特性的值</p><h5 id="attributes属性："><a href="#attributes属性：" class="headerlink" title="attributes属性："></a>attributes属性：</h5><p><code>NameNodeMap</code>：动态的类数组集合。</p><blockquote><p>元素的每一个特性都由一个<code>Attr</code>节点表示，每个节点都保存在<code>NameNodeMap</code>对象中</p></blockquote><p><code>NameNodeMap</code>对象方法：</p><ul><li><code>getNameItem( name )</code>：返回<code>nodeName</code>属性等于<code>name</code>的节点</li><li><code>removeNamedItem( name )</code>：移除<code>nodeName</code>属性等于<code>name</code>的节点</li><li><code>setNamedItem( node )</code>：向列表中添加节点，以节点的<code>nodeName</code>属性为索引</li><li><code>item( index )</code>：返回位于<code>index</code>位置处的节点</li></ul><blockquote><p><code>removeNodeItem()</code>  ==  <code>removeAttriibute()</code></p></blockquote><h5 id="创建元素："><a href="#创建元素：" class="headerlink" title="创建元素："></a>创建元素：</h5><p><code>document.createElement(&quot;TagName&quot;);</code>：创建一个新元素</p><blockquote><p>要把新元素添加到文档树，可以用<code>appendChild()</code>、<code>insertBrfore()</code>、<code>replaceChild()</code>方法</p></blockquote><h5 id="元素的子节点："><a href="#元素的子节点：" class="headerlink" title="元素的子节点："></a>元素的子节点：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 01<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 02<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 03<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>在IE浏览器中：ul元素的子节点有3个，分别是3个li元素。</p></li><li><p>在其他浏览器中：ul元素子节点有7个，分别是3个li元素，和4个li元素两边的空白符</p></li></ul><blockquote><p>在使用子节点时，要注意检查<code>nodeType</code>属性，防止错误</p></blockquote><h4 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h4><p>照字面解释的纯文本内容。</p><p><code>Text</code>节点具有以下<strong>特征</strong>：</p><ul><li><code>nodeType</code>值是<code>3</code></li><li><code>nodeName</code>的值是<code>&quot;#Text&quot;</code></li><li><code>nodeValue</code>的值为<code>节点所包含的文本</code></li><li><code>parentNode</code>是一个<code>Element</code></li><li>不支持（没有）子节点</li></ul><blockquote><p><code>nodeValue</code>   ==   <code>data</code></p></blockquote><p>操作节点中的文本：</p><ul><li><p><code>appendDate(text);</code>：将text添加至节点的末尾</p></li><li><p><code>deleteData(offset, count);</code>：从指定<code>offset</code>开始删除<code>count</code>个字符</p></li><li><p><code>insertData(offset, text);</code>：从<code>offset</code>指定的位置插入<code>text</code></p></li><li><p><code>replaceData(offset, count, text);</code>：用<code>text</code>替换从<code>offset</code>指定的位置到<code>offset+count</code>结束</p></li><li><code>splitText(offset);</code>：从<code>offset</code>指定位置将当前文本节点分成两个文本节点</li><li><code>substringData(offset, count);</code>：提取从<code>offset</code>指定的位置开始到<code>offset+count</code>为止的字符串</li></ul><p><code>length</code>属性：保存文本节点中字符的数量</p><h5 id="创建文本节点："><a href="#创建文本节点：" class="headerlink" title="创建文本节点："></a>创建文本节点：</h5><p><code>document.createTextNode(text);</code>：创建新的文本节点</p><h5 id="规范化文本节点："><a href="#规范化文本节点：" class="headerlink" title="规范化文本节点："></a>规范化文本节点：</h5><p><code>normalize()</code>方法：如果在一个包含两个或多个文本节点的父元素上调用该方法，则会将所有文本节点合并成一个节点。</p><h5 id="分割文本节点："><a href="#分割文本节点：" class="headerlink" title="分割文本节点："></a>分割文本节点：</h5><p><code>splitText( index );</code>：根据指定位置分割文本节点</p><h4 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h4><p><code>Comment</code>类型既<strong>注释类型</strong>，它具有以下<strong>特征</strong>：</p><ul><li><code>nodeType</code>的值是<code>8</code></li><li><code>nodeName</code>的值为<code>&quot;#comment&quot;</code></li><li><code>nodeValue</code>的值是注释的内容</li><li><code>parentNode</code>可能是<code>Element</code>或<code>Document</code></li><li>不支持（没有）子节点</li></ul><p><code>Comment</code>类型与<code>Text</code>类型继承于相同的基类，因此它拥有除<code>splitText()</code>外<strong>所有的字符串操作方法</strong>。</p><h4 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h4><p>只针对基于XML的文档，表示的是CDATA区域。</p><blockquote><p>与<code>Comment</code>类似，<code>CDATASection</code>类型继承自<code>Text</code>类型，拥有除<code>splitText()</code>外<strong>所有的字符串操作方法</strong>。</p></blockquote><p><code>CDATASection</code>类型具有以下<strong>特征</strong>：</p><ul><li><code>nodeType</code>的值为<code>4</code></li><li><code>nodeName</code>的值为<code>&quot;#data-section&quot;</code></li><li><code>nodeValue</code>的值是CDATA区域中的内容</li><li><code>parentNode</code>可能是<code>Element</code>或<code>Document</code></li><li>不支持（没有）子节点</li></ul><h4 id="DoucmentType类型"><a href="#DoucmentType类型" class="headerlink" title="DoucmentType类型"></a>DoucmentType类型</h4><p>包含着与文档的<code>doctype</code>有关的所有信息，具有以下<strong>特征</strong>：</p><ul><li><p><code>nodeType</code>的值为<code>10</code></p></li><li><p><code>nodeName</code>的值为doctype的名称</p></li><li><p><code>nodeValue</code>的值为<code>null</code></p></li><li><p><code>parentNode</code>的值是<code>Document</code></p></li><li><p>不支持（没有）子节点</p><blockquote><p>仅有Firefox、Safari、Opera支持</p></blockquote></li></ul><h5 id="DOM1级中："><a href="#DOM1级中：" class="headerlink" title="DOM1级中："></a>DOM1级中：</h5><p>不能动态创建<code>DocumentType</code>对象，只能通过解析代码的方式来创建。对象保存在<code>document.doctype</code>中。</p><p><code>DocumentType对象属性</code>：</p><ul><li><code>name</code>：表示文档类型的名称</li><li><code>entities</code>：文档类型描述的实体的<code>NamedNodeMap</code>对象</li><li><code>notations</code>：文档类型的描述符号的<code>NamedNodeMap</code>对象</li></ul><blockquote><p>一般情况下entities和notations都是空列表</p></blockquote><h4 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h4><blockquote><p>不建议直接访问属性节点</p></blockquote><p>元素的特性在DOM中以Attr类型来表示。在所有浏览器中都可以访问Attr类型的构造函数和原型。</p><p>特性就是存在于元素的<code>attributes</code>属性中的节点，它具有以下<strong>特征</strong>：</p><ul><li><code>nodeType</code>的值为<code>2</code></li><li><code>nodeName</code>的值为特性的名称</li><li><code>nodeValue</code>的值为特性的值</li><li><code>parentNode</code>的值是<code>null</code></li><li>在HTML中不支持（没有）子节点</li><li>在 XML 中子节点可能是Text或 EntityReference</li></ul><h5 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h5><ul><li><p>name：特性名称</p></li><li><p>value：特性的值</p></li><li><p>specified：布尔值，判断是自定义特性还是默认特性</p></li></ul><h3 id="DOM操作技术"><a href="#DOM操作技术" class="headerlink" title="DOM操作技术"></a>DOM操作技术</h3><h4 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h4><p>页面加载时不存在，但将来的某一时刻通过修改DOM动态添加的脚本。</p><p><strong>动态添加脚本方式</strong>：<code>插入外部文件</code>和<code>直接插入Javascript代码</code></p><p>插入外部文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备插入脚本的的代码</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"script.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 利用DOM方式插入脚本并封装成一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);  <span class="comment">// 创建Script对象</span></span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;                <span class="comment">// 设置类型</span></span><br><span class="line">    script.src = url;                               <span class="comment">// 设置脚本地址</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);              <span class="comment">// 将脚本添加至body元素中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载外部脚本</span></span><br><span class="line">loadScript(<span class="string">"script.js"</span>);</span><br></pre></td></tr></table></figure><p>直接插入Javascript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备插入脚本的的代码</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"script.js"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Hi"</span>);</span><br><span class="line">&#125;    </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 利用DOM方式插入脚本</span></span><br><span class="line"><span class="regexp">var script = document.createElement("script");   /</span><span class="regexp">/ 创建Script对象</span></span><br><span class="line"><span class="regexp">    script.type = "text/</span>javascript<span class="string">";                 // 设置类型</span></span><br><span class="line"><span class="string">    script.text = "</span>fucntion sayHi()&#123; alert(<span class="string">'Hi'</span>) &#125;<span class="string">"; // 设置脚本地址</span></span><br><span class="line"><span class="string">    document.body.appendChild(script);               // 将脚本添加至body元素中</span></span><br></pre></td></tr></table></figure><h4 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h4><p>添加CSS样式的两种方式：<link>包含外部文件，<style>内嵌样式代码。</p><p>插入<link>元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备要插入的外联样式代码</span></span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"style.css"</span>&gt;</span><br><span class="line"><span class="comment">// 使用DOM代码动态创建元素并封装函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyles</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);  <span class="comment">//创建&lt;link&gt;元素</span></span><br><span class="line">    link.rel = <span class="string">"stylesheet"</span>;</span><br><span class="line">    link.type = <span class="string">"text/css"</span>;</span><br><span class="line">    link.href = url;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTageName(<span class="string">"head"</span>)[<span class="number">0</span>];</span><br><span class="line">    head.appendChild(link);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入外联样式表</span></span><br><span class="line">loadStyles(url);</span><br></pre></td></tr></table></figure><p>内嵌式CSS：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步操作，动态添加，兼容IE</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyleString</span>(<span class="params">css</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</span><br><span class="line">    style.type = <span class="string">"text/css"</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        style.appendChild(<span class="built_in">document</span>.createTextNode(css));</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ex)&#123;</span><br><span class="line">        style.styleSheet.cssText = css;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementByTagName(<span class="string">"head"</span>)[<span class="number">0</span>];</span><br><span class="line">    head.appendChild(style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DOM总结"><a href="#DOM总结" class="headerlink" title="DOM总结"></a>DOM总结</h3><h2 id="DOM是语言中立的API，用于访问HTML和XML文档。DOM将文档看成一个层次化的节点树。"><a href="#DOM是语言中立的API，用于访问HTML和XML文档。DOM将文档看成一个层次化的节点树。" class="headerlink" title="DOM是语言中立的API，用于访问HTML和XML文档。DOM将文档看成一个层次化的节点树。"></a>DOM是语言中立的API，用于访问HTML和XML文档。DOM将文档看成一个层次化的节点树。</h2></style></p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;DOM节点层次，DOM事件类型&lt;/p&gt;
          &lt;/div&gt;
&lt;p&gt;DOM是针对HTML和XML文档的一个API。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IE中所有的DOM对象都是以COM对象的形式实现的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;节点层次&quot;&gt;&lt;a href=&quot;#节点层次&quot; class=&quot;headerlink&quot; title=&quot;节点层次&quot;&gt;&lt;/a&gt;节点层次&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DOM可以将任何HTML或XML文档描绘长城一个&lt;strong&gt;多层节点&lt;/strong&gt;构成的结构。
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.xucha0.cn/categories/JavaScript/"/>
    
    
      <category term="Web前端" scheme="http://www.xucha0.cn/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://www.xucha0.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="DOM" scheme="http://www.xucha0.cn/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>BOM事件对象</title>
    <link href="http://www.xucha0.cn/BOM%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.xucha0.cn/BOM事件对象/</id>
    <published>2018-11-22T08:56:51.000Z</published>
    <updated>2018-11-22T08:56:51.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>Window对象、Location对象、Navigator对象、Screen对象、History对象</p>          </div><h3 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h3><p>表示一个<strong>浏览器的实例</strong>，它既是通过Js访问浏览器的一个接口，又是ECMAScript规定的<code>Global</code>对象。</p><p>在网页中定义的任何一个变量、对象、函数，都以<code>window</code>作为其<code>Global</code>对象。<br><a id="more"></a></p><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>由于<code>window</code>对象为ECMAScript中的<code>Global</code>对象，因此<strong>所有在全局作用域中声明的变量、函数都会变成<code>window</code>对象的属性和方法</strong>。</p><blockquote><p><strong>直接定义变量与在window上定义变量的差别</strong>：全局变量不能通过<code>delete</code>操作符删除，而直接在<code>window</code>对象上定义的可以</p></blockquote><p><strong>使用全局变量方式创建，她的window属性有一个[[Configurable]]特性，它的值被设置为false，所以不能用delete操作符删除</strong></p><p>尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个未声明的变量是否存在：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newValue = oldValue;   <span class="comment">// error, oldValue is not undefined</span></span><br><span class="line"><span class="keyword">var</span> newValue = <span class="built_in">window</span>.oldValue;   <span class="comment">// 不会报错，因为这是一次属性查询</span></span><br></pre></td></tr></table></figure><h4 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h4><p>如果页面中包含框架，则每个框架都有自己的<code>window</code>对象，并且保存在<code>frames</code>集合中。</p><p>通过代码访问框架的六种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.frames[ index ];</span><br><span class="line"><span class="built_in">window</span>.frames[ name ];</span><br><span class="line">top.frames[ index ];     <span class="comment">// 建议使用</span></span><br><span class="line">top.frames[ name ];      <span class="comment">// 建议使用</span></span><br><span class="line">frames[ index ];</span><br><span class="line">frames[ name ];</span><br></pre></td></tr></table></figure><p><code>parent</code>对象：始终指向当前框架的直接上层框架，在某些情况下有可能等于<code>top</code>，在没有框架的情况下一定等于<code>top</code>。</p><p><code>self</code>对象：它始终指向<code>window</code>，<code>self</code>和<code>window</code>可以互换使用。</p><blockquote><p>使用框架的情况下，浏览器会存在多个<code>Global</code>对象。每个框架中定义的全局变量也会成为各自框架中<code>window</code>对象的属性，因此每个框架都有一套自己的构造函数，一一对应，但不相等。</p></blockquote><h4 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h4><p><strong>IE,Safari,Opera,Chrome：</strong></p><p><code>screenLeft</code>属性：获取窗口相对于屏幕左边的位置</p><p><code>screenTop</code>属性：获取窗口相对于屏幕上边的位置</p><p><strong>Firefox,Safari,Chrome,IE,Opera[与screenLeft,screenTop不相对应]：</strong></p><p><code>screenX</code>属性：获取窗口相对于屏幕左边的位置</p><p><code>screenY</code>属性：获取窗口相对于屏幕上边的位置</p><p>兼容代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>)?</span><br><span class="line">    <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>)?</span><br><span class="line">    <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure><h4 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h4><p><code>innerWidth</code>、<code>innerHeight</code>属性：该容器中页面视图区的大小（减去边框宽度）</p><p><code>outerWidth</code>、<code>outerHeight</code>属性：返回浏览器窗口本身的尺寸</p><h5 id="调整浏览器窗口的大小："><a href="#调整浏览器窗口的大小：" class="headerlink" title="调整浏览器窗口的大小："></a>调整浏览器窗口的大小：</h5><blockquote><p>可能会被浏览器禁用</p></blockquote><p><code>resizeTo(width, height)</code>：浏览器窗口的新尺寸</p><p><code>resizeBy(width, height)</code>：新窗口与原窗口尺寸差</p><h4 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h4><p><code>window.open(URL[, Target, String, Boolean]);</code>：导航到一个特定的URL或者打开一个浏览器窗口。</p><p>URL：要加载的URL地址</p><p>Target：窗口目标</p><ul><li>窗口或框架的名称，没有则新建</li><li>_self：URL替换当前页面</li><li>_parent：URL替换父框架</li><li>_top：URL替换任何可加载的框架集</li><li>_blank：URL加载到一个新的窗口[<strong>默认</strong>]</li></ul><p>String：一个特性字符串</p><table><thead><tr><th>设置</th><th>说明</th></tr></thead><tbody><tr><td>channelmode=yes/no/1/0</td><td>是否要在影院模式显示 window。默认是没有的。仅限IE浏览器</td></tr><tr><td>directories=yes/no/1/0</td><td>是否添加目录按钮。默认是肯定的。仅限IE浏览器</td></tr><tr><td>fullscreen=yes/no/1/0</td><td>浏览器是否显示全屏模式。默认是没有的。在全屏模式下的 window，还必须在影院模式。仅限IE浏览器</td></tr><tr><td>height=pixels</td><td>窗口的高度。最小.值为100</td></tr><tr><td>left=pixels</td><td>该窗口的左侧位置</td></tr><tr><td>location=yes/no/1/0</td><td>是否显示地址字段.默认值是yes</td></tr><tr><td>menubar=yes/no/1/0</td><td>是否显示菜单栏.默认值是yes</td></tr><tr><td>resizable=yes/no/1/0</td><td>是否可调整窗口大小.默认值是yes</td></tr><tr><td>scrollbars=yes/no/1/0</td><td>是否显示滚动条.默认值是yes</td></tr><tr><td>status=yes/no/1/0</td><td>是否要添加一个状态栏.默认值是yes</td></tr><tr><td>titlebar=yes/no/1/0</td><td>是否显示标题栏.被忽略，除非调用HTML应用程序或一个值得信赖的对话框.默认值是yes</td></tr><tr><td>toolbar=yes/no/1/0</td><td>是否显示浏览器工具栏.默认值是yes</td></tr><tr><td>top=pixels</td><td>窗口顶部的位置.仅限IE浏览器</td></tr><tr><td>width=pixels</td><td>窗口的宽度.最小.值为100</td></tr></tbody></table><p>Boolean：新页面是否取代浏览器历史记录中当前页面加载的布尔值</p><h5 id="窗口引用与关闭"><a href="#窗口引用与关闭" class="headerlink" title="窗口引用与关闭"></a>窗口引用与关闭</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wroxWin = <span class="built_in">window</span>.open( ... );      <span class="comment">//返回一个指向新窗口的引用</span></span><br><span class="line">wroxWin.resizeTo(<span class="number">100</span>,<span class="number">100</span>);             <span class="comment">//对窗口大小可以直接进行调整</span></span><br><span class="line">wroxWin.close();                       <span class="comment">//window.close();方法可以关闭打开的窗口</span></span><br></pre></td></tr></table></figure><p><code>opener属性</code>：保存打开它的原始窗口对象。</p><p><strong>只在弹出窗口中最外层window对象中有定义，并且指向调用window.open()的窗口或框架</strong></p><blockquote><p>将<code>opener属性</code>设置为<code>null</code>，即表示在单独的进程中运行标签页</p></blockquote><h5 id="弹出窗口屏蔽程序"><a href="#弹出窗口屏蔽程序" class="headerlink" title="弹出窗口屏蔽程序"></a>弹出窗口屏蔽程序</h5><ol><li>浏览器内置程序屏蔽：<code>window.open( ... );</code>返回<code>null</code>。</li><li>浏览器扩展程序屏蔽：<code>window.open( ... );</code>返回<code>error</code>。</li></ol><blockquote><p>要判定弹出窗口是否被屏蔽，必须在检测返回值的同时，将对<code>window.open();</code>的调用封装在一个<code>try-catch</code>块中。</p></blockquote><h4 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h4><h5 id="超时调用："><a href="#超时调用：" class="headerlink" title="超时调用："></a>超时调用：</h5><p><code>setTimeout(code, Time)</code>方法。</p><p><strong>指定时间只调用一次代码</strong></p><ul><li>code：执行的代码（字符串或者是函数）</li><li>Time：以毫秒表示的时间（执行代码需要等待的时间）</li></ul><blockquote><p>Javascript是一个单线程的解释器，因此一定时间内只能执行一段代码，所以setTimeout()方法的实质含义是：告诉JS再过多长时间把当前的任务添加到队列中。</p><p>如果队列是空的，代码立即执行；如果不是空的，则按顺序执行。</p></blockquote><p>返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeoutId = setTimeout( ... );</span><br></pre></td></tr></table></figure><blockquote><p>调用setTimeout()方法，会返回一个数值ID，表示超时调用，这个超时调用是计划执行代码唯一的标识符，可以用它来取消超时调用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearTimeout(timeoutId);            <span class="comment">//取消超时调用</span></span><br></pre></td></tr></table></figure><h5 id="间歇调用："><a href="#间歇调用：" class="headerlink" title="间歇调用："></a>间歇调用：</h5><p><code>setInterval(code, Time)</code>方法。</p><p><strong>按照指定的时间间隔循环执行代码</strong></p><ul><li>code：执行的代码（字符串或者是函数）</li><li>Time：以毫秒表示的时间（代码循环执行的时间间隔）</li></ul><p>取消间歇调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intervalId = setInterval( ... );</span><br><span class="line">clearInterval(intervalId);</span><br></pre></td></tr></table></figure><h4 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h4><p>“警告”对话框：<code>alert( ... );</code> [只有一个确定按钮]</p><p>“确认”对话框：<code>var bool = confirm( ... );</code>[确认和取消两个按钮]    <strong>单击确认返回ture</strong></p><p>“提示”对话框：<code>prompt(string [,default]);</code>[输入框及确认取消两个按钮]    <strong>单击确认返回输入框字符串，否则返回null</strong></p><p>打印对话框：<code>window.print();</code></p><p>查找对话框：<code>window.find();</code></p><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>既是<code>window对象</code>的属性，又是<code>document对象</code>的属性，所以<strong><code>window.location == document.location</code></strong></p><table><thead><tr><th>属性名</th><th style="text-align:left">例子</th><th>说明</th></tr></thead><tbody><tr><td>hash</td><td style="text-align:left"><code>&quot;#contents&quot;</code></td><td>返回URL中的hash（#后面跟零和多个字符），如果URL中不包括散列，则返回空字符串</td></tr><tr><td>host</td><td style="text-align:left"><code>&quot;www.xucha0.cn:80&quot;</code></td><td>返回服务器名称和端口号</td></tr><tr><td>hostname</td><td style="text-align:left"><code>&quot;www.xucha0.cn&quot;</code></td><td>返回不带端口号的服务器名称</td></tr><tr><td>href</td><td style="text-align:left"><code>&quot;http://www.xucha0.cn&quot;</code></td><td>返回当前加载页面的完整<code>URL</code>。而<code>location对象</code>的<code>toString();</code>方法返回的也是这个值</td></tr><tr><td>pathname</td><td style="text-align:left"><code>&quot;/admin/&quot;</code></td><td>返回URL中的目录和文件名</td></tr><tr><td>port</td><td style="text-align:left"><code>&quot;8080&quot;</code></td><td>返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串。</td></tr><tr><td>protocol</td><td style="text-align:left"><code>&quot;http:&quot;</code></td><td>返回页面使用的协议。通常是<code>http:</code>或<code>https:</code></td></tr><tr><td>search</td><td style="text-align:left"><code>&quot;?name=xuchao&quot;</code></td><td>返回URL的查询字符串。这个字符串以问号开头</td></tr></tbody></table><h4 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h4><p>对<code>location.search();</code>中返回的字符串进行切片：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 取得查询字符串并去掉开头的问号</span></span><br><span class="line">    <span class="keyword">var</span> qs = (location.search.length &gt; <span class="number">0</span> ? location.search.substring(<span class="number">1</span>) : <span class="string">""</span>),</span><br><span class="line">    <span class="comment">// 保存数据的对象</span></span><br><span class="line">    args = &#123;&#125;,</span><br><span class="line">    <span class="comment">// 取得每一项</span></span><br><span class="line">    items = qs.length ? qs.split(<span class="string">"&amp;"</span>) : [],</span><br><span class="line">    item = <span class="literal">null</span>,</span><br><span class="line">        name = <span class="literal">null</span>,</span><br><span class="line">        value = <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">// 在for循环中使用</span></span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = items.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个将每一项添加到args对象中</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        item = items[i].split(<span class="string">"="</span>);</span><br><span class="line">        name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</span><br><span class="line">        value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (name.length) &#123;</span><br><span class="line">            args[name] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解析页面<code>location.search</code>返回的字符串，并返回一个包含字符串内所有键值对的对象。</p></blockquote><h4 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h4><p><code>location.assign(URL);</code> ：打开新的URL并在浏览器的历史记录中生成一条记录。</p><blockquote><p>使用<code>window.location</code>或<code>location.href</code>设置一个URL的值也会调用<code>assign()</code>方法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location = <span class="string">"http://www.xuchao.cn"</span>;  ==  location.assign(<span class="string">"http://www.xuchao.cn"</span>);</span><br><span class="line">location.href = <span class="string">"http://www.xuchao.cn"</span>;    ==  location.assign(<span class="string">"http://www.xuchao.cn"</span>);</span><br></pre></td></tr></table></figure><p><code>location.replace(URL);</code>：打开新的URL，但不会在历史记录中生成新记录，既不能返回。</p><p><code>location.reload( [true] );</code>：重新加载当前显示的页面。</p><blockquote><p>不传参数，页面从浏览器缓存中重新加载；传入true参数，页面强制从服务器重新加载。</p></blockquote><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><hr><table><br>  <tbody><tr><br>    <th style="width:30%">属性或方法</th><br>    <th>描述</th><br>  </tr><br>  <tr><br>    <td>appCodeName</td><br>    <td>浏览器的名称。通常都是Mozilla，即使在非Mozilla浏览器中也是如此</td><br>  </tr><br>  <tr><br>    <td>appMinorVersion</td><br>    <td>浏览器的次级版本。</td><br>  </tr><br>  <tr><br>    <td>appName</td><br>    <td>完整的浏览器名称。</td><br>  </tr><br>  <tr><br>    <td>appVersion</td><br>    <td>浏览器的平台和版本信息，一般不与实际的浏览器版本对应。</td><br>  </tr><br>  <tr><br>    <td>cookieEnabled</td><br>    <td>表示cookie是否启用</td><br>  </tr><br>  <tr><br>    <td>javaEnabled()</td><br>    <td>表示当前浏览器中是否启用了Java</td><br>  </tr><br>  <tr><br>    <td>Language</td><br>    <td>返回当前浏览器的主语言。</td><br>  </tr><br>  <tr><br>    <td>mimeTyoes</td><br>    <td>在浏览器中注册的MIME类型数组</td><br>  </tr><br>  <tr><br>    <td>onLine</td><br>    <td>表示浏览器是否连接了因特网</td><br>  </tr><br>  <tr><br>    <td>platform</td><br>    <td>返回运行浏览器的操作系统平台。</td><br>  </tr><br>  <tr><br>    <td>plugins</td><br>    <td>浏览器中安装插件信息的数组。</td><br>  </tr><br>  <tr><br>    <td>systemLanguage</td><br>    <td>返回 OS 使用的默认语言。（仅IE 4.0+支持）</td><br>  </tr><br>  <tr><br>    <td>userAgent</td><br>    <td>返回由客户机发送服务器的 user-agent 头部的值。</td><br>  </tr><br>  <tr><br>    <td>userLanguage</td><br>    <td>返回 OS 的自然语言设置。（仅IE 4.0+和Opera 7.0+支持）</td><br>  </tr><br></tbody></table><h4 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h4><p><code>window.navigator.plugins</code>属性，返回一个有关插件信息的数组。</p><ul><li><code>name</code>：插件的名字</li><li><code>description</code>：插件的描述</li><li><code>filename</code>：插件的文件名</li><li><code>length</code>：插件所处理的MIME类型数量</li></ul><h5 id="检测非IE浏览器："><a href="#检测非IE浏览器：" class="headerlink" title="检测非IE浏览器："></a>检测非IE浏览器：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测插件(非IE)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    name = name.toLowerCase();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;navigator.plugins.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测Flash</span></span><br><span class="line">alert(hasPlugin(<span class="string">"Flash"</span>));</span><br><span class="line"><span class="comment">// 检测QuickTime</span></span><br><span class="line">alert(hasPlugin(<span class="string">"QuickTime"</span>));</span><br></pre></td></tr></table></figure><h5 id="检测IE浏览器："><a href="#检测IE浏览器：" class="headerlink" title="检测IE浏览器："></a>检测IE浏览器：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测插件(IE)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasIEPlugin</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ActiveXObject(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测Flash</span></span><br><span class="line"><span class="built_in">console</span>.log(hasIEPlugin(<span class="string">"shockwaveFlash.shockwaveFlash"</span>));</span><br><span class="line"><span class="comment">// 检测QuiceTime</span></span><br><span class="line"><span class="built_in">console</span>.log(hasIEPlugin(<span class="string">"QuiceTime.QuiceTime"</span>));</span><br></pre></td></tr></table></figure><h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><table><thead><tr><th>属性</th><th>说明</th><th style="text-align:center">IE</th><th style="text-align:center">Firefox</th><th style="text-align:center">Safari/chrome</th><th style="text-align:center">Opera</th></tr></thead><tbody><tr><td>availHeight</td><td>屏幕的像素高度减系统部件高度之后的值（只读）</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center"></td></tr><tr><td>availLeft</td><td>未被系统部件占用的最左侧的像素值（只读）</td><td style="text-align:center"></td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center"></td></tr><tr><td>availTop</td><td>未被系统部件占用的最上方的像素值（只读）</td><td style="text-align:center"></td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center"></td></tr><tr><td>availWidth</td><td>屏幕的像素宽度减系统部件宽度之后的值（只读）</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td>bufferDepth</td><td>读、写用于呈现屏外位图的位数</td><td style="text-align:center">yes</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>colorDepth</td><td>用于表现颜色的位数；多数系统都是32（只读）</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td>deviceXDPI</td><td>屏幕实际的水平DPI（只读）</td><td style="text-align:center">yes</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>deviceYDPI</td><td>屏幕实际的垂直DPI（只读）</td><td style="text-align:center">yes</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>fontSmooth- ingEnabled</td><td>表示是否启用了字体平滑（只读）</td><td style="text-align:center">yes</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>height</td><td>屏幕</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td>left</td><td>当前屏幕距左边的像素距离</td><td style="text-align:center"></td><td style="text-align:center">yes</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>logicalXDPI</td><td>屏幕逻辑的水平DPI（只读）</td><td style="text-align:center">yes</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>logicalYDPI</td><td>屏幕逻辑的垂直DPI（只读）</td><td style="text-align:center">yes</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>pixelDepth</td><td>屏幕的位深（只读）</td><td style="text-align:center"></td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr><tr><td>top</td><td>当前屏幕距上边的像素距离</td><td style="text-align:center"></td><td style="text-align:center">yes</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>updateInterval</td><td>读、写以毫秒表示的屏幕刷新时间间隔</td><td style="text-align:center">yes</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td>width</td><td>屏幕的像素高度</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr></tbody></table><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>保存着用户上网的历史记录。</p><p><code>history.go( intValue/String );</code>方法：前进或后退页面。</p><blockquote><p><code>history.go( -1 );</code>：后退一页。</p><p><code>history.go( 1 );</code>：前进一页。</p><p><code>history.go( &quot;xucha0.cn&quot; );</code>：跳转到包含<code>xucha0.cn</code>最近的页面。- <strong>可能前进，也可能后退</strong> -</p></blockquote><p><code>history.back();</code>：后退一页。<br><code>history.forward();</code>：前进一页。<br><code>history.length</code>：保存历史记录数量。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;Window对象、Location对象、Navigator对象、Screen对象、History对象&lt;/p&gt;
          &lt;/div&gt;
&lt;h3 id=&quot;Window对象&quot;&gt;&lt;a href=&quot;#Window对象&quot; class=&quot;headerlink&quot; title=&quot;Window对象&quot;&gt;&lt;/a&gt;Window对象&lt;/h3&gt;&lt;p&gt;表示一个&lt;strong&gt;浏览器的实例&lt;/strong&gt;，它既是通过Js访问浏览器的一个接口，又是ECMAScript规定的&lt;code&gt;Global&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;在网页中定义的任何一个变量、对象、函数，都以&lt;code&gt;window&lt;/code&gt;作为其&lt;code&gt;Global&lt;/code&gt;对象。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.xucha0.cn/categories/JavaScript/"/>
    
    
      <category term="Web前端" scheme="http://www.xucha0.cn/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://www.xucha0.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="BOM" scheme="http://www.xucha0.cn/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>JS函数表达式</title>
    <link href="http://www.xucha0.cn/JS%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.xucha0.cn/JS函数表达式/</id>
    <published>2018-11-15T10:16:47.000Z</published>
    <updated>2018-11-15T10:16:47.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>JS函数的递归、闭包、模仿块级作用域、及函数的私有变量。</p>          </div><h4 id="定义函数："><a href="#定义函数：" class="headerlink" title="定义函数："></a>定义函数：</h4><ol><li>函数声明：</li></ol><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1, ... </span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;  <span class="comment">// name属性访问函数名</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>函数声明提升</strong>：执行代码之前会先读取函数声明。所以即便函数声明在调用函数代码之后，也不会报错。</p></blockquote><ol start="2"><li>函数表达式：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, ... </span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;;  <span class="comment">//匿名函数</span></span><br></pre></td></tr></table></figure><blockquote><p>并没有函数声明提升，使用之前必须先赋值。</p></blockquote><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>一个函数通过名字调用自身的情况下称为递归函数</p><p><strong>问题：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnuc</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num*func(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherFunc = func;</span><br><span class="line">func = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anotherFunc(<span class="number">10</span>));    <span class="comment">// error,因为func指向的已经变成null而不再是函数</span></span><br></pre></td></tr></table></figure><p><strong>解决办法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnuc</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num*argeuments.callee(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line"><span class="keyword">var</span> func = (<span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>递归函数使用<code>arguments.callee</code>来递归调用自身，不需要使用函数名。</strong></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>有权访问另一个函数作用域中的变量称为闭包。</p><p><strong>闭包是内部函数在其父函数已经终止之后可以引用其外部封闭函数中存在的变量的一种手段。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span> (<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">object_1, object_2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> value_1 = object_1(propertyName);</span><br><span class="line">        <span class="keyword">var</span> value_2 = object_2(propertyName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// 即使内部函数被返回，而且在其他地方调用了，但他依然可以访问变量property</span></span><br><span class="line">   <span class="comment">// 原因是因为内部函数作用域链始终包含Func()的作用域</span></span><br></pre></td></tr></table></figure><blockquote><p>​    当某个函数被调用时，会创建一个<strong>执行环境</strong>及相应的<strong>作用域链</strong>，使用<code>argeuments</code>和<code>其他命名参数</code>来<strong>初始化函数的活动对象</strong>。</p><p>​    但在作用域链中，外部函数活动对象始终处于第二位，外部函数的外部函数活动对象始终处在第三位，以此类推，知道作用域链的终点为<strong>全局执行环境</strong>。</p></blockquote><h4 id="闭包与变量："><a href="#闭包与变量：" class="headerlink" title="闭包与变量："></a>闭包与变量：</h4><h5 id="闭包的副作用："><a href="#闭包的副作用：" class="headerlink" title="闭包的副作用："></a>闭包的副作用：</h5><p>闭包只能取得包含函数中任何变量的<strong>最后一个值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arr</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;             <span class="comment">// i的值一直为10             </span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以利用创建另一个匿名函数强制让闭包符合预期：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arr</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;                     </span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this对象："><a href="#this对象：" class="headerlink" title="this对象："></a>this对象：</h4><p>匿名函数的执行环境具有全局性，因此<code>this对象</code>通常指向<code>window</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Dad"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"Son"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(objject.getNameFunc()());   <span class="comment">// "Dad" 在非严格模式下</span></span><br></pre></td></tr></table></figure><p>将外部作用域中的<code>this</code>保存在一个<code>闭包能够访问的变量</code>里，就能让闭包访问该变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Dad"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"Son"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(objject.getNameFunc()());    <span class="comment">//"Son"</span></span><br></pre></td></tr></table></figure><p><strong>过度的使用闭包，会占用大量的内存。</strong></p><h3 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h3><p>JavaScript没有块级作用域的概念，所以在块语句中定义的变量，实际上是在包含函数中创建的而非语句中创建的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numbers</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        alert(i);                    </span><br><span class="line">    &#125;   <span class="comment">// 一般拥有块级作用域的语言，在循环结束后，便对循环内定义的变量进行销毁。</span></span><br><span class="line">    <span class="keyword">var</span> i;   <span class="comment">// 重新声明变量，会被执行，但并不覆盖原来的i</span></span><br><span class="line">    alert(i);  <span class="comment">// 输出正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决办法</strong>：利用<code>匿名函数</code>模仿块级作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里是块级作用域</span></span><br><span class="line">&#125;)();  <span class="comment">// 后面的圆括号表示立即执行函数,其等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> var func = function ()&#123;</span></span><br><span class="line"><span class="comment">   // 块级作用域</span></span><br><span class="line"><span class="comment"> &#125;;</span></span><br><span class="line"><span class="comment"> func();</span></span><br><span class="line"><span class="comment">***********************/</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>优点</strong>：可以减少闭包中占有内存的问题，由于没有指向匿名函数的引用，所以只要函数执行完毕就被销毁。</p></blockquote><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>任何在函数中定义的变量，都认为是私有变量，因为不能在函数的外部访问这些变量。</p><p>私有变量包括：函数的参数、局部变量、在函数中定义的其他函数。</p><h5 id="特权方法："><a href="#特权方法：" class="headerlink" title="特权方法："></a>特权方法：</h5><p>有权访问<code>私有变量</code>和<code>私有函数</code>的公有方法称为特权方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用构造函数定义特权方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>构造函数模式针对每个实例都会创造一个新方法，利用静态私有变量可以解决这个问题。</p></blockquote><h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><p>通过在私有作用域中定义私有变量和函数，创建特权方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   <span class="comment">// 创建私有域</span></span><br><span class="line">    <span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      <span class="comment">// 初始化未经声明的变量，总是会创建全局变量 [非严格模式下]</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 公有/特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><p>为单例创建私有变量和特权方法。单例即只有一个实例的对象。</p><p>单例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'Xuchao'</span>,</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 方法代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模块模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 特权/公有方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> &#123;             <span class="comment">// 单例的公共接口</span></span><br><span class="line">        publicProperty: <span class="literal">true</span>;</span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">       <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h4 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h4><p>如果要返回一个特定模式的对象，则需要用到增强的模块模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 私有函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">    <span class="comment">// 特权/公有方法和属性</span></span><br><span class="line">object.publicProperty = <span class="literal">true</span>;</span><br><span class="line">    object.publicMethod   = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">       <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> object;   <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;JS函数的递归、闭包、模仿块级作用域、及函数的私有变量。&lt;/p&gt;
          &lt;/div&gt;
&lt;h4 id=&quot;定义函数：&quot;&gt;&lt;a href=&quot;#定义函数：&quot; class=&quot;headerlink&quot; title=&quot;定义函数：&quot;&gt;&lt;/a&gt;定义函数：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;函数声明：&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.xucha0.cn/categories/JavaScript/"/>
    
    
      <category term="ECMAScript5" scheme="http://www.xucha0.cn/tags/ECMAScript5/"/>
    
      <category term="Web前端" scheme="http://www.xucha0.cn/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://www.xucha0.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JS面向对象程序设计</title>
    <link href="http://www.xucha0.cn/JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://www.xucha0.cn/JS面向对象程序设计/</id>
    <published>2018-11-14T09:49:21.000Z</published>
    <updated>2018-11-14T09:49:21.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>JavaScript关于面向对象语法操作及基础知识</p>          </div><h3 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h3><h4 id="创建对象的方式："><a href="#创建对象的方式：" class="headerlink" title="创建对象的方式："></a>创建对象的方式：</h4><a id="more"></a><ul><li><p>实例化对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure></li><li><p>对象字面量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; ... &#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="属性类型："><a href="#属性类型：" class="headerlink" title="属性类型："></a>属性类型：</h4><h5 id="数据属性："><a href="#数据属性：" class="headerlink" title="数据属性："></a>数据属性：</h5><p>包含一个数据值的位置。在这个位置可以读取和写入值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: xuchao, ... &#125;;     <span class="comment">// name为数据属性</span></span><br></pre></td></tr></table></figure><h6 id="4个描述其行为的特性："><a href="#4个描述其行为的特性：" class="headerlink" title="4个描述其行为的特性："></a>4个描述其行为的特性：</h6><ul><li>[ [ Configurable ] ]：表示能否通过delete删除属性，能否修改属性的特性，能否把属性修改为访问器属性。默认为true。</li><li>[ [ Enumerable ] ] ：表示能否通过for-in循环返回属性。默认为true。</li><li>[ [ Writable ] ]        ：表示能否修改属性的值。默认为true。</li><li>[ [ Value ] ]             ：属性的数据值。默认为undefined。</li></ul><h6 id="修改属性默认的特性："><a href="#修改属性默认的特性：" class="headerlink" title="修改属性默认的特性："></a>修改属性默认的特性：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty( <span class="built_in">Object</span> , propertyName, obj );</span><br><span class="line"><span class="comment">/********************************************</span></span><br><span class="line"><span class="comment"> Object: 属性所在的对象,</span></span><br><span class="line"><span class="comment"> propertyName: 属性名,</span></span><br><span class="line"><span class="comment"> obj: 描述符对象  &#123; Writable ： false, ..... &#125;</span></span><br><span class="line"><span class="comment">********************************************/</span></span><br></pre></td></tr></table></figure><blockquote><p>使用<code>Object.defineProperty()</code>创建新属性时，如果不指定，则<code>Configurable</code>，<code>Enumerable</code>，<code>Writable</code>默认为  <strong>false</strong></p></blockquote><h5 id="访问器属性："><a href="#访问器属性：" class="headerlink" title="访问器属性："></a>访问器属性：</h5><p>不包含数值。不能直接定义，智能通过<code>Object.defineProperty()</code>定义。</p><ul><li><p>[ [ Configurable ] ]：表示能否通过delete删除属性，能否修改属性的特性，能否把属性修改为访问器属性。</p></li><li><p>[ [ Enumerable ] ] ：表示能否通过for-in循环返回属性。默认为true。</p></li><li><p>[ [ Get ] ]                ：读取属性时调用的函数。默认为undefined。</p></li><li><p>[ [ Set ] ]                 ：在写入属性时调用的函数。默认为undefined。</p></li></ul><h4 id="定义多个属性："><a href="#定义多个属性：" class="headerlink" title="定义多个属性："></a>定义多个属性：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties( <span class="built_in">Object</span> , &#123;</span><br><span class="line">    propertyName_1: &#123;</span><br><span class="line">writable: ... ,</span><br><span class="line">          ...</span><br><span class="line">    &#125;,</span><br><span class="line">    propertyName_2: &#123;</span><br><span class="line">        writable: ... ,</span><br><span class="line">          ...</span><br><span class="line">    &#125;,</span><br><span class="line">    ....</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="读取属性的特性："><a href="#读取属性的特性：" class="headerlink" title="读取属性的特性："></a>读取属性的特性：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.getOwnPropertyDescriptor( <span class="built_in">Object</span> , propertyName );</span><br><span class="line"><span class="comment">//返回一个对象，如果是数据属性，则对象属性为数据属性的特性，访问器属性同理。</span></span><br></pre></td></tr></table></figure><h3 id="创建对象："><a href="#创建对象：" class="headerlink" title="创建对象："></a>创建对象：</h3><h4 id="工厂模式："><a href="#工厂模式：" class="headerlink" title="工厂模式："></a>工厂模式：</h4><p>用函数封装对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o  = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age  = age;</span><br><span class="line">    a.job  = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化一个对象</span></span><br><span class="line"><span class="keyword">var</span> person_1 = createPerson(<span class="string">"Xuchao"</span>, <span class="number">23</span>, <span class="string">"Web Security Engineer"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>缺点：没有解决对象识别问题</p></blockquote><h4 id="构造函数模式："><a href="#构造函数模式：" class="headerlink" title="构造函数模式："></a>构造函数模式：</h4><p>创造自定义的函数构造属性和方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age  = age;</span><br><span class="line">    <span class="keyword">this</span>.job  = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化一个对象</span></span><br><span class="line"><span class="keyword">var</span> person_1 = <span class="keyword">new</span> Person(<span class="string">"Xuchao"</span>, <span class="number">23</span>, <span class="string">"Web Security Engineer"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>实例化对象后会产生一个<code>constructor</code>（构造函数）属性，该属性指向原型，既 <code>person_1.constructor = Person</code></p></blockquote><blockquote><p>优点：解决工厂模式的缺点。</p><p>缺点：每个方法需要在每个实例上重新创建一遍。</p></blockquote><h4 id="原型模式："><a href="#原型模式：" class="headerlink" title="原型模式："></a>原型模式：</h4><p>让所有对象实例共享原型对象的属性和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.prototype.name = <span class="string">"Xuchao"</span>;</span><br><span class="line">    Person.prototype.age  = <span class="number">23</span>;</span><br><span class="line">    Person.prototype.job  = <span class="string">"Web Security Engineer"</span>;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化一个对象</span></span><br><span class="line"><span class="keyword">var</span> person_1 = <span class="keyword">new</span> Person();</span><br><span class="line">person_1.sayName();   <span class="comment">// "Xuchao"</span></span><br><span class="line">alert(person_1.sayName() == person_2.sayName());  <span class="comment">// "true"</span></span><br></pre></td></tr></table></figure><h5 id="理解原型对象："><a href="#理解原型对象：" class="headerlink" title="理解原型对象："></a>理解原型对象：</h5><blockquote><p>1、<code>Obj.prototype.isPrototypeOf( obj_x );</code>   判断obj_x中是否有Obj.prototype的指针</p><p>2、<code>Object.prototype.getPrototypeOf( obj_x );</code>  返回obj_x中[ [ prototype ] ]的值</p></blockquote><p>​    为实例添加名字相同的属性，会将指针指向实例属性而屏蔽掉原型属性上的值，若想让指针重新指向原型属性，需用 <code>delete</code> 删除实例属性。</p><blockquote><p><code>Obj.hasOwnPrototype( propertyName )</code>  判断属性值是实例属性还是原型属性</p></blockquote><h5 id="原型与in操作符："><a href="#原型与in操作符：" class="headerlink" title="原型与in操作符："></a>原型与in操作符：</h5><p>单独使用 <code>in</code> 操作符，可以判断指定属性是否可以通过对象访问到（与实力属性、原型属性无关，只要能访问该属性都返回<code>true</code>）</p><blockquote><p>与<code>hasOwnProperty()</code>方法结合使用可以判断该属性是存在于实例对象中，还是存在于原型中。</p></blockquote><p><code>Object.keys( Element )</code>   - 接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数学组</p><p><code>Object.getOwnPropertyNames( Element )</code>  - 得到所有实力属性，无论它是否可枚举</p><h5 id="更简单的原型语法："><a href="#更简单的原型语法：" class="headerlink" title="更简单的原型语法："></a>更简单的原型语法：</h5><p>通过对象字面量重写原型对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">'Xuchao'</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">    job: <span class="string">'Web'</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>使用该方法重写原型，<code>constructor</code> 将<strong>不再</strong>指向<code>Person</code>，而是指向<code>Object</code>，解决方法如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>： Person，   //解决<span class="keyword">constructor</span>不指向Person的问题</span><br><span class="line">      ...</span><br><span class="line">&#125;;//此方法会将<span class="keyword">constructor</span>变为可枚举对象，即[ [ Enumberable ] ]特性被设置为true</span><br></pre></td></tr></table></figure><h5 id="原型的动态性："><a href="#原型的动态性：" class="headerlink" title="原型的动态性："></a>原型的动态性：</h5><p>对原型对象所进行的任何修改都能够立即从实例上反映出来，因为指向原型的是一个指针而不是一个副本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi();    <span class="comment">// "Hi"</span></span><br></pre></td></tr></table></figure><p>​    <strong>重写原型对象后，实例指向的依旧是原来的原型对象而非新的原型对象</strong></p><h5 id="原型对象的问题："><a href="#原型对象的问题：" class="headerlink" title="原型对象的问题："></a>原型对象的问题：</h5><ol><li>省略了为构造函数传递初始化参数的环节，结果会导致所有的实例具有相同的属性值。</li><li>原型中所有的属性都是被很多实例共享的，在一个实例中修改原型属性其他实例也同样会修改。</li></ol><h4 id="组合使用构造函数模式和原型模式："><a href="#组合使用构造函数模式和原型模式：" class="headerlink" title="组合使用构造函数模式和原型模式："></a>组合使用构造函数模式和原型模式：</h4><p><strong>构造函数模式用于定义实例属性，原始模式用于定义方法和共享的属性</strong></p><pre><code>&gt; 每一个实例都会有一份实例属性的副本，但又同时共享着对方法的引用</code></pre><h4 id="寄生构造函数模式："><a href="#寄生构造函数模式：" class="headerlink" title="寄生构造函数模式："></a>寄生构造函数模式：</h4><p>创建一个函数，封装创建对象的代码，再返回新创建的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;   <span class="comment">//一般情况下不建议使用</span></span><br><span class="line">    <span class="keyword">var</span> o  = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age  = age;</span><br><span class="line">    a.job  = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化一个对象</span></span><br><span class="line"><span class="keyword">var</span> person_1 = <span class="keyword">new</span> Person(<span class="string">"Xuchao"</span>, <span class="number">23</span>, <span class="string">"Web Security Engineer"</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>与工厂模式区别</strong>：使用<code>new</code>操作符，包装函数叫做构造函数</p></blockquote><h4 id="稳妥构造函数模式："><a href="#稳妥构造函数模式：" class="headerlink" title="稳妥构造函数模式："></a>稳妥构造函数模式：</h4><ol><li>没有公共属性</li><li>其方法不引用<code>this对象</code></li></ol><p>与其他模式不同：</p><ol><li>新建方法不引用<code>this</code></li><li>不使用<code>new</code>操作符调用构造函数</li></ol><blockquote><p>适合在安全执行环境下使用</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>利用原型链实现继承。</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>一个实例指向原型对象，而原型对象又是另一个原型的实例，层层叠进，构成原型链。</p><h5 id="默认原型："><a href="#默认原型：" class="headerlink" title="默认原型："></a>默认原型：</h5><p>所有的引用类型都继承了<code>Object</code>，所有函数都是<code>Object</code>的实例。因此默认原型都会包含一个指针指向<code>Object.prototype</code>。</p><p><strong>原型和实例的关系：</strong></p><ol><li><code>instanceof</code>操作符</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>      <span class="comment">//实例instance是否在对象Object中  true/false</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>isPrototypeOf</code>方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(instance)  <span class="comment">//同上</span></span><br></pre></td></tr></table></figure><h5 id="原型链定义需要注意的问题："><a href="#原型链定义需要注意的问题：" class="headerlink" title="原型链定义需要注意的问题："></a>原型链定义需要注意的问题：</h5><ol><li>给原型添加方法的代码一定要放在替换原型的语句以后</li><li>通过原型链事先继承时，不能使用对象字面量创建原型方法。因为这样会重写原型链。</li></ol><h4 id="借用构造函数（伪造对象、经典继承）"><a href="#借用构造函数（伪造对象、经典继承）" class="headerlink" title="借用构造函数（伪造对象、经典继承）"></a>借用构造函数（伪造对象、经典继承）</h4><p>在子类型构造函数的内部调用超类型构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 继承了SuperType</span></span><br><span class="line">    SuperType.apply(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不会共享属性，而是会通过apply()方法产生一个副本</p></blockquote><ol><li>可以在子类型构造函数中向超类型构造函数传递参数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"> name </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 继承了SuperType,同时还传递了参数</span></span><br><span class="line">    SuperType.apply(<span class="keyword">this</span>, <span class="string">'Xuchao'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法函数无法复用，在超类型原型定义的方法，对子类型也不可见。</li></ol><h4 id="组合继承（伪经典继承）"><a href="#组合继承（伪经典继承）" class="headerlink" title="组合继承（伪经典继承）"></a>组合继承（伪经典继承）</h4><p>将原型链和借用构造函数的技术结合到一块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 利用构造函数模式创建原型属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 利用原型链的方式创建原型方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>借助原型中可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;     <span class="comment">// 创建一个临时性的构造函数</span></span><br><span class="line">    F.prototype = o;   <span class="comment">// 将传入的对象作为这个构造函数的原型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();    <span class="comment">// 返回了这个临时类型的一个新实例</span></span><br><span class="line">&#125; <span class="comment">// 其本质是object对传入的对象进行了一次浅复制</span></span><br></pre></td></tr></table></figure><p>ES5通过新增<code>Object.create()</code>方法规范了原型式继承：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(protoObj, propeytyObj[可选])  <span class="comment">//新对象的原型对象， 为新对象定义额外属性的对象</span></span><br></pre></td></tr></table></figure><blockquote><p>包含引用类型值得属性始终都会共享相应的值，就像是用原型模式一样</p></blockquote><h4 id="寄生类继承"><a href="#寄生类继承" class="headerlink" title="寄生类继承"></a>寄生类继承</h4><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再返回对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params"> func_1 </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object( func_1 );   <span class="comment">// 通过调用函数创建一个新对象[可以用其他方式]</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;       <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">        alert(<span class="string">"Hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;   <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>通过借用构造函数来继承属性，通过原型链的混合形式来继承方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params"> subType, superType </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);   <span class="comment">// 创建对象</span></span><br><span class="line">    prototype.constructor = subType;               <span class="comment">// 增强对象</span></span><br><span class="line">    subType.prototype = prototype;                 <span class="comment">// 指定对象</span></span><br><span class="line">&#125;<span class="comment">// 只调用一次SuperType构造函数，避免了在SubType.prototype上创建不必要的、多余的属性，且原型链不变</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;JavaScript关于面向对象语法操作及基础知识&lt;/p&gt;
          &lt;/div&gt;
&lt;h3 id=&quot;对象：&quot;&gt;&lt;a href=&quot;#对象：&quot; class=&quot;headerlink&quot; title=&quot;对象：&quot;&gt;&lt;/a&gt;对象：&lt;/h3&gt;&lt;h4 id=&quot;创建对象的方式：&quot;&gt;&lt;a href=&quot;#创建对象的方式：&quot; class=&quot;headerlink&quot; title=&quot;创建对象的方式：&quot;&gt;&lt;/a&gt;创建对象的方式：&lt;/h4&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.xucha0.cn/categories/JavaScript/"/>
    
    
      <category term="ECMAScript5" scheme="http://www.xucha0.cn/tags/ECMAScript5/"/>
    
      <category term="Web前端" scheme="http://www.xucha0.cn/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://www.xucha0.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Object-Oriented" scheme="http://www.xucha0.cn/tags/Object-Oriented/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础</title>
    <link href="http://www.xucha0.cn/JavaScript%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.xucha0.cn/JavaScript基础/</id>
    <published>2018-09-11T09:30:28.000Z</published>
    <updated>2018-09-11T09:30:28.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note default">            <p>Javascript基础语法</p>          </div><h2 id="JavaScript组成部分"><a href="#JavaScript组成部分" class="headerlink" title="JavaScript组成部分"></a>JavaScript组成部分</h2><ul><li><p>ECMAScript (基础语法——核心)     </p><ul><li>语法</li><li>类型<a id="more"></a></li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>对象</li></ul></li><li><p>DOM (Document Object Model 文档对象模型)</p><blockquote><p>提供访问和操作网页内容的方法和接口</p></blockquote><ul><li><p>DOM1级</p><blockquote><p>主要是映射文档的结构</p></blockquote><ul><li>DOM核心 (映射基于XML文档结构)</li><li>DOM HTML (基于DOM核心，添加对HTML的对象和方法)</li></ul></li><li><p>DOM2级</p><blockquote><p>在原来DOM的基础上又扩充了鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，通过对象接口增加了对CSS的支持</p></blockquote><ul><li>DOM视图（DOM Views）：定义了跟踪不同文档视图的接口</li><li>DOM事件（DOM Events）：定义了事件和事件处理的接口</li><li>DOM样式（DOM Style）：定义了基于CSS为元素应用样式的接口</li><li>DOM遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口</li></ul></li><li><p>DOM3级</p><blockquote><p>进一步扩展了DOM，引入了以统一方式加载和保存文档的方法；新增了验证文档的方法</p></blockquote></li></ul></li><li><p>BOM (Browser Object Model 浏览器对象模型)</p><blockquote><p>提供与浏览器交互的方法和接口</p></blockquote></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>简单数据类型：Undefined、Null、Boolean、Number、String</p><p>复杂数据类型：Object</p><ul><li><p>Array</p></li><li><p>Function</p></li><li><p>Date</p></li><li><p>RegExp</p></li><li><p>………..</p><h5 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符 "></a>typeof操作符 <!--返回变量数据类型--></h5><h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h3><blockquote><p>表示初始化但未声明的变量，一般不显式赋值，多用于比较</p></blockquote><h3 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h3><blockquote><p>表示一个空指针<strong>对象</strong> ，多以typeof会显示”object”,实际上Undefined是派生自NULL，所以 <code>null == undefined</code> 的返回值是<code>true</code></p></blockquote><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><blockquote><p><code>true</code>和<code>false</code>区分大小写，<code>True</code>和<code>False</code>不是<code>Boolean</code>值，只是标识符    </p></blockquote><h4 id="转化Boolean值-：boolean-函数"><a href="#转化Boolean值-：boolean-函数" class="headerlink" title="转化Boolean值 ：boolean();函数"></a>转化Boolean值 ：<code>boolean();</code>函数</h4></li></ul><table><thead><tr><th style="text-align:center"><strong>数据类型</strong></th><th style="text-align:center">转换为true的值</th><th style="text-align:center">转换为false的值</th></tr></thead><tbody><tr><td style="text-align:center">Boolean</td><td style="text-align:center">true</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">任何非空字符串</td><td style="text-align:center">“ ”（空字符串）</td></tr><tr><td style="text-align:center">Number</td><td style="text-align:center">任何非零数字值（包括无穷大）</td><td style="text-align:center">0和NaN</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">任何对象</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">Undefined</td><td style="text-align:center"></td><td style="text-align:center">undefined</td></tr></tbody></table><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><blockquote><p>使用IEEE754格式来表示整数和浮点</p></blockquote><ul><li><p>整型</p><ul><li>十进制    <code>var num = 10;</code></li><li>八进制    <code>var num = 070;</code></li><li>十六进制    <code>var num = 0x5f；</code></li></ul><blockquote><p>在进行算术计算时，所有的八进制和十六进制都被转化为十进制</p></blockquote></li><li><p>浮点型</p><blockquote><p>浮点数最高精度为17位</p></blockquote><p><code>0.1 + 0.2 = 0.30000000000000004</code> (js浮点运算会产生误差)</p></li><li><p>数值范围</p><p>最大值： <code>Number.MIN_VALUE</code></p><p>最小值： <code>Number.MAX_VALUE</code></p><blockquote><p>超出数值范围的数会被自动转换成为特殊的<code>Infinity</code>值，<code>Infinity</code>表示正无穷，<code>-Infinity</code>表示负无穷，<code>Infinity</code>值无法参加运算，可以用<code>isFinite();</code>函数判断数值是否是有穷的。</p></blockquote></li><li><p>NaN (Not a Number)</p><blockquote><p>表示一个本来要返回数值的操作数未返回数值的情况。</p></blockquote><ul><li><p>特点</p><ol><li><p>任何涉及NaN的操作都会返回NaN，除以0的操作也返回NaN</p><blockquote><p>实际上只有NaN / NaN才返回NaN，整数除以NaN返回Infinity，负数除以NaN返回-Infinity</p></blockquote></li><li><p>NaN与任何值都不相等，包括他本身</p></li></ol></li><li><p>判定：<code>isNaN();</code>函数</p><ul><li><code>isNaN( NaN ) == true</code></li><li><code>isNaN( 10 ) == false</code></li><li><code>isNaN( &quot;10&quot; ) == false</code> (可以被转换成数值10)</li><li><code>isNaN( &quot;blue&quot; ) == true</code></li><li><code>isNaN( true )  == false</code> (可以被转换成数值1)</li></ul></li></ul></li><li><p>数值转换</p><ol><li><p>Number();</p><ul><li>如果是布尔值，true和false将分别转为1和0.</li><li>如果是数字值，只是简单地传入和返回。</li><li>如果是NULL值，返回0.</li><li>如果是undefined，返回NaN</li><li>如果是字符串：<ol><li>如果字符串只包含数字，则将其转化为十进制数值</li><li>如果字符串中包含有效的浮点格式，则将其转化为对应的浮点数值</li><li>如果字符串中包含有效的十六进制格式，则转化为相同大小的十进制形式</li><li>如果字符是空的，则将其转化为0</li><li>如果字符串包含上述格式之外的字符，则将其转化为NaN</li></ol></li><li>如果是对象，则调用valueOf()方法，然后依照前面的规则返回值。如果转换得是NaN，则调用toString();方法。</li></ul></li><li><p>parseInt();</p><blockquote><p>忽略字符串前面的空格，直到找到第一个非空字符，如果第一个字符不是数字字符或者符号，则返回NaN。否则会直接解析完最后一个数字字符</p></blockquote></li><li><p>parsefloat();</p><blockquote><p>与parseInt();类似</p></blockquote></li></ol><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3></li><li><p>特点</p><blockquote><p>ECMAScript中的字符串是不可变的，要改变，只能先销毁再赋值，也就是覆盖。</p></blockquote></li><li><p>转换字符串</p><ol><li><p><code>toString();</code>方法</p><blockquote><p><code>null</code>和<code>undefined</code>没有这个方法</p></blockquote><p>参数：null，2，8，10，16     <code>改变进制</code></p></li><li><p><code>String();</code>方法</p></li></ol><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><blockquote><p>ECMAScript中的对象其实就是一组数据和功能的集合。</p></blockquote></li><li><p>创建对象</p><ol><li><code>var obj = new Object();</code></li><li><code>var obj = { ... };</code></li></ol></li><li><p>Object属性和方法</p><ul><li><code>constructor</code>：保存着用于创建当前对象的函数</li><li><code>hasOwnProperty( propertyName )</code>：用于检查给定的属性在当前的对象实例中是否存在</li><li><code>isPropertypeOf( object )</code>：用于检查传入的对象是否是传入对象的原型</li><li><code>propertyIsEnumerable( propertyName )</code>：用于检查给定的属性是否能够使用for-in语句来枚举</li><li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串与执行环境的地区对应</li><li><code>toString()</code>：返回对象的字符串表示</li><li><code>valueOf()</code>：返回对象的字符串数值或布尔值表示，通常与<code>toString()</code>方法返回的值相同</li></ul><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3></li><li><p>for-in语句</p><ul><li><p>迭代语句，循环显示BOM中对象的所有属性（无序的）</p><blockquote><p>如果对象中属性值为null或者undefined，则会终止循环</p></blockquote></li></ul></li><li><p>with语句</p><ul><li>将代码的作用域设置到一个特定的对象中（严格模式不支持）</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>​    参数：函数可以传入多个参数，而且不需要定义形参接受，他们会被存入伪数组arguments中。</p><p>​    重载：js函数没有重载，只能覆盖。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note default&quot;&gt;
            &lt;p&gt;Javascript基础语法&lt;/p&gt;
          &lt;/div&gt;
&lt;h2 id=&quot;JavaScript组成部分&quot;&gt;&lt;a href=&quot;#JavaScript组成部分&quot; class=&quot;headerlink&quot; title=&quot;JavaScript组成部分&quot;&gt;&lt;/a&gt;JavaScript组成部分&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ECMAScript (基础语法——核心)     &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法&lt;/li&gt;
&lt;li&gt;类型
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.xucha0.cn/categories/JavaScript/"/>
    
    
      <category term="ECMAScript5" scheme="http://www.xucha0.cn/tags/ECMAScript5/"/>
    
      <category term="Web前端" scheme="http://www.xucha0.cn/tags/Web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://www.xucha0.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
